/* This is the T4c recursive parser */
/* and all implemented functions that can be triggered */

// NOTE: things that break my poor recursive-parser:
// NOTE: never use SPACES/TAB when listing function parameters, before/after commas
//       never use \" literal double quotes inside the double quotes of a function parameter
//          All "If" expects an "Else", even if empty
//          All Ifs and Elses need { and } presented explicitely
//      as in:
//              If(HasItem(60))
//                  { Digue("You have this item!") }
//              Else
//                  { Digue("You still don't have item 60" }

void spawnMarket(int alvox, int alvoy, int density)
// random spawn obj tile index 80 -97 starting at (alvox,alvoy)
//  density determines size:
/////////////////////// 1->3x3 square,2->6x6 square,3->9x9 square
{
    int j,i;
    for (j=0; j < density*3; j++ )
        for (i=0; i < density*3; i++ )
            mapa[alvoy+i][alvox+j].obj = ((rand()%17)+80)*(rand()%2);

}

void spawnModel(const char idT[], int alvox, int alvoy)
{
// This function spawns centered at (alvox,alvoy) the "idT" of a model.
// models.dat is generated by mkModels.c, it contains prefab obj
// models.dat is loaded at startup,
// the binary file contais the definition of an array of idT + struct Tijolos[9]

    int j, i, kk=0; // z;

    for (int ii=0; ii <=N_MODEL; ii++) {
        //printf("%s\n", Modelito[ii].idT);
if ( strcmp(Modelito[ii].idT, idT) == 0 )
{

    for (i=-1; i<=1; i++)
     for (j=-1; j<=1; j++)
        {

           mapa[alvoy+i][alvox+j].base = Modelito[ii].bricks[kk].base;
           mapa[alvoy+i][alvox+j].obj = Modelito[ii].bricks[kk].obj;
           mapa[alvoy+i][alvox+j].cri = Modelito[ii].bricks[kk].cri;
           mapa[alvoy+i][alvox+j].top = Modelito[ii].bricks[kk].top;
           mapa[alvoy+i][alvox+j].flag = Modelito[ii].bricks[kk].flag;
           kk++;
        }


       }
    } // Modelito [ii]

}


void Walk(int alvox, int alvoy, double falvox, double falvoy)
{
// This function moves player targeted at (alvox, alvoy)
// using a delinquent implementation of A* algorithm
// there are several triggers to abort and avoid too much recursion
// but sometimes it breaks

    unsigned long int GAMBZ = Tempo; // to prevent infinite loop

    if ( ataca ) return;

    if ( !movendo )
      movendo = 1;
      else if ( movendo > 2 ) {
                movendo = 0;
                return;
                }


	struct pathfinder **pathsight;

	int i,j,ii,jj,n=1;
	unsigned long int k,kk,count_list=1;

	i = EGO.y; j=EGO.x;

	pathsight = malloc(size_mapa*sizeof(struct pathfinder *));
	if ( pathsight == NULL ) printf("Err alloc pathfinding\n");
	for (ii=0; ii<=size_mapa-1; ii++)
	{
		pathsight[ii] = malloc(size_mapa*sizeof(struct pathfinder));
		if ( pathsight[ii] == NULL ) printf("Err alloc pathfinding[][]\n");
	}

	for (ii=0; ii<=size_mapa-1; ii++)
		for (jj=0; jj<=size_mapa-1; jj++)
			{ pathsight[ii][jj].F = 0; pathsight[ii][jj].G = 0; pathsight[ii][jj].H = 0;
			pathsight[ii][jj].N = 0; pathsight[ii][jj].bloq = 0; pathsight[ii][jj].list = 2; }

	for (ii=0; ii<=size_mapa-1; ii++)
		for (jj=0; jj<=size_mapa-1; jj++)
			if ( mapa[ii][jj].obj != 0 )
				pathsight[ii][jj].bloq = 1;

	for (ii=0; ii<=size_mapa-1; ii++)
	{ pathsight[0][ii].bloq = 1; pathsight[size_mapa-2][ii].bloq = 1; }


	for (ii=0; ii<=size_mapa-1; ii++)
	{ pathsight[ii][0].bloq = 1; pathsight[size_mapa-2][ii].bloq = 1; }

	pathsight[i][j].list = 0;
	pathsight[i][j].parx = j;
	pathsight[i][j].pary = i;

	for (ii=0;ii<=2;ii++)
		for(jj=0;jj<=2;jj++)
			if (pathsight[i+(ii-1)][j+(jj-1)].bloq != 1 )
			{
				pathsight[i+(ii-1)][j+(jj-1)].list = 0;
				pathsight[i+(ii-1)][j+(jj-1)].parx = j;
				pathsight[i+(ii-1)][j+(jj-1)].pary = i;
				pathsight[i+(ii-1)][j+(jj-1)].G = abs((ii-1)*(jj-1));
				if (pathsight[i+(ii-1)][j+(jj-1)].G == 1) pathsight[i+(ii-1)][j+(jj-1)].G = 14;
				else pathsight[i+(ii-1)][j+(jj-1)].G = 10;
				pathsight[i+(ii-1)][j+(jj-1)].H =  10*(abs( (j+(jj-1))-alvox ) + abs( (i+(ii-1))-alvoy ) );
				pathsight[i+(ii-1)][j+(jj-1)].F = pathsight[i+(ii-1)][j+(jj-1)].G+pathsight[i+(ii-1)][j+(jj-1)].H;
			}

	pathsight[i][j].list = 1;

	// Move player with lame A* algorithm, no collision detection
	while ( pathsight[alvoy][alvox].list != 1 && count_list )
	{

	/////// TO PREVENT INFINITE LOOPZ WE ABORT IF FUNCTION TAKES TOO LONG
        Act_Tempo(); // for gambiarra fix
        if ( GAMBZ+2 < Tempo ) {
                                    Play_Snd("snd/alarm.wav");
                                    Digue("no route to path");
                                        movendo--;
                                   if ( alvox-EGO.x < 0 ) EGO.sprite = 2;    //face LEFT
                                    if ( alvox-EGO.x > 0 ) EGO.sprite = 4; // face RIGHT
                                    if ( alvoy-EGO.y < 0 ) EGO.sprite = 0;    // face UP
                                    if ( alvoy-EGO.y > 0 ) EGO.sprite = 6;    //face down



						for (ii=0;ii<=size_mapa-1;ii++)
							free (pathsight[ii]);
						free (pathsight); return; }
//////////////////////////////////////////////////////////// THIS REALLY SUX

			k=0; kk=1000000;
			for (ii=0;ii<=size_mapa-2;ii++)
				for(jj=0;jj<=size_mapa-2;jj++)
				if (pathsight[ii][jj].list == 0 )
				{
					k = pathsight[ii][jj].F;
					if (k < kk && k != 0) kk = k;
				}

			k=0;
			for (ii=0;ii<=size_mapa-2&&k==0;ii++)
				for(jj=0;jj<=size_mapa-2&&k==0;jj++)
				if (pathsight[ii][jj].F == kk && pathsight[ii][jj].list == 0 )
				{
					i = ii; j = jj;
					if (i < 1 )
                        i = 1;
					if (i > size_mapa-2)
                        i = size_mapa-2;
					if (j < 1 )
                        j = 1;
                    if (j > size_mapa-2)
                        j = size_mapa-2;
					pathsight[i][j].list = 1;
					k=1;
				}

			for (ii=0;ii<=2;ii++)
				for(jj=0;jj<=2;jj++)
				if (pathsight[i+(ii-1)][j+(jj-1)].bloq != 1 && pathsight[i+(ii-1)][j+(jj-1)].list != 1 )
				{
				if (pathsight[i+(ii-1)][j+(jj-1)].list == 0)
				{
					k = abs((ii-1)*(jj-1));
					if ( k == 0 ) k=10; else k=14;
					if (k+pathsight[i][j].G < pathsight[i+(ii-1)][j+(jj-1)].G)
					{
						pathsight[i+(ii-1)][j+(jj-1)].parx = j;
						pathsight[i+(ii-1)][j+(jj-1)].pary = i;

						if (abs((ii-1)*(jj-1)) == 0)
							pathsight[i+(ii-1)][j+(jj-1)].G = pathsight[pathsight[i+(ii-1)][j+(jj-1)].pary][pathsight[i+(ii-1)][j+(jj-1)].parx].G + 10;
						else pathsight[i+(ii-1)][j+(jj-1)].G = pathsight[pathsight[i+(ii-1)][j+(jj-1)].pary][pathsight[i+(ii-1)][j+(jj-1)].parx].G + 14;


						pathsight[i+(ii-1)][j+(jj-1)].F = pathsight[i+(ii-1)][j+(jj-1)].G+pathsight[i+(ii-1)][j+(jj-1)].H;
					}
				}
				if (pathsight[i+(ii-1)][j+(jj-1)].list == 2)
					{
					pathsight[i+(ii-1)][j+(jj-1)].parx = j;
					pathsight[i+(ii-1)][j+(jj-1)].pary = i;

					if ( abs((ii-1)*(jj-1)) == 0)
						pathsight[i+(ii-1)][j+(jj-1)].G = pathsight[pathsight[i+(ii-1)][j+(jj-1)].pary][pathsight[i+(ii-1)][j+(jj-1)].parx].G + 10;
					else pathsight[i+(ii-1)][j+(jj-1)].G = pathsight[pathsight[i+(ii-1)][j+(jj-1)].pary][pathsight[i+(ii-1)][j+(jj-1)].parx].G + 14;

					pathsight[i+(ii-1)][j+(jj-1)].H = 10*(abs( (j+(jj-1))-alvox ) + abs( (i+(ii-1))-alvoy ) );
					pathsight[i+(ii-1)][j+(jj-1)].F = pathsight[i+(ii-1)][j+(jj-1)].G+pathsight[i+(ii-1)][j+(jj-1)].H;
					pathsight[i+(ii-1)][j+(jj-1)].list = 0;
					}


				}

			count_list=0;
			for (ii=0; ii<=size_mapa-2;ii++)
				for (jj=0; jj<=size_mapa-2;jj++)
					if (pathsight[ii][jj].list == 0)
						count_list++;
			if ( !count_list ) {
                                    Play_Snd("snd/alarm.wav");
                                    Digue("no path to move command");
                                        movendo--;
                                   if ( alvox-EGO.x < 0 ) EGO.sprite = 2;    //face LEFT
                                    if ( alvox-EGO.x > 0 ) EGO.sprite = 4; // face RIGHT
                                    if ( alvoy-EGO.y < 0 ) EGO.sprite = 0;    // face UP
                                    if ( alvoy-EGO.y > 0 ) EGO.sprite = 6;    //face down



						for (ii=0;ii<=size_mapa-1;ii++)
							free (pathsight[ii]);
						free (pathsight); return; }

	}

	kk=0; pathsight[i][j].N = n;
	ii = pathsight[i][j].pary; jj = pathsight[i][j].parx;

	while ( jj != EGO.x || ii != EGO.y )
	{
		n++;
		pathsight[pathsight[i][j].pary][pathsight[i][j].parx].N = n;
		ii = pathsight[i][j].pary; jj = pathsight[i][j].parx;
		i = ii; j = jj;

	}


while (kk != 1 && act_n )
	{

Input_Teclado();

			k=0;kk=0;
			for ( ii=0; ii<=size_mapa-1; ii++)
				for (jj=0;jj<=size_mapa-1; jj++)
					if ( pathsight[ii][jj].N != 0 )
					{
						k = pathsight[ii][jj].N;
						if ( k > kk  ) kk = k;
					}
			i=0; j=0; k=0;
			for ( ii=0; ii<=size_mapa-1&&k==0; ii++)
				for (jj=0;jj<=size_mapa-1&&k==0; jj++)
					if ( pathsight[ii][jj].N == kk)
					{
						pathsight[ii][jj].N = 0;
						if (EGO.x > jj) j = -1;
						if (EGO.x == jj) j = 0;
						if (EGO.x < jj) j = 1;
						if (EGO.y > ii) i = -1;
						if (EGO.y == ii) i = 0;
						if (EGO.y < ii) i = 1;
						k=1;
					}



while   ( (EGO.x != jj-1 || EGO.y != ii-1 ) && act_n && movendo < 3 )
			{


Act_Tempo();
    if ( EGO.hp <= 0 ) { Play_Music("snd/music11.ogg"); Digue_Window("PLAYER morreu");
          //  SDL_UpdateWindowSurface(window);
            SDL_RenderPresent(window_renderer);

            act_n=0; }


if ( tac.tic )  {

                if ( j < 0 ) EGO.sprite = 2;    //face LEFT
				if ( j > 0 ) EGO.sprite = 4; // face RIGHT
                if ( i > 0 ) EGO.sprite = 0;    // face UP
				if ( i < 0 ) EGO.sprite = 6;    //face down

    movendo++;
				EGO.xvel = STEP*(float)(j); // step by step.. uhh babe
				EGO.yvel = STEP*(float)(i); // one step at a time, like everybody else */
    Input_Teclado();
        Desenha_Tudo(); //
	        Atualiza_Tudo();  // keep spinning the engine

                EGO.xvel = 0;
                EGO.yvel = 0;
                    movendo--;

         Desenha_stats();  // :D

            SDL_RenderPresent(window_renderer);

        }

     } // (?) look here



	} // while kk != 1

                movendo = 0;

	for (ii=0;ii<=size_mapa-1;ii++)
		free (pathsight[ii]);
	free (pathsight);


}

void Walk_NPC(int alvox, int alvoy, int nn)
{
// This function moves NPC index k, as of cartola[k], targeted at (alvox, alvoy)
// using a delinquent implementation of A* algorithm
// there are several triggers to abort and avoid too much recursion
// but sometimes it breaks

    unsigned long int GAMBZ = Tempo; // to prevent infinite loop

	struct pathfinder **pathsight;

	int i,j,ii,jj,n=1,k,kk,count_list=1;
	float *pcocozal, cocozal;

	pcocozal = &cocozal;

			 if ( !meowvendo )
                meowvendo = 1;
            else if ( meowvendo > 2 ) {
                meowvendo = 0;
            return;
                }

	i = cartola[nn].y; j=cartola[nn].x;

	pathsight = malloc(size_mapa*sizeof(struct pathfinder *));
	if ( pathsight == NULL ) printf("err alloc pathfinding\n");
	for (ii=0; ii<=size_mapa-1; ii++)
	{
		pathsight[ii] = malloc(size_mapa*sizeof(struct pathfinder));
		if ( pathsight[ii] == NULL ) printf("Err alloc pathfinding[][]\n");
	}

	for (ii=0; ii<=size_mapa-1; ii++)
		for (jj=0; jj<=size_mapa-1; jj++)
			{ pathsight[ii][jj].F = 0; pathsight[ii][jj].G = 0; pathsight[ii][jj].H = 0;
			pathsight[ii][jj].N = 0; pathsight[ii][jj].bloq = 0; pathsight[ii][jj].list = 2; }

	for (ii=0; ii<=size_mapa-1; ii++)
		for (jj=0; jj<=size_mapa-1; jj++)
			if ( mapa[ii][jj].obj != 0 )
				pathsight[ii][jj].bloq = 1;

	for (ii=0; ii<=size_mapa-1; ii++)
	{ pathsight[0][ii].bloq = 1; pathsight[size_mapa-2][ii].bloq = 1; }

	for (ii=0; ii<=size_mapa-1; ii++)
	{ pathsight[0][ii].bloq = 1; pathsight[size_mapa-2][ii].bloq = 1; }

	pathsight[i][j].list = 0;
	pathsight[i][j].parx = j;
	pathsight[i][j].pary = i;

	for (ii=0;ii<=2;ii++)
		for(jj=0;jj<=2;jj++)
			if (pathsight[i+(ii-1)][j+(jj-1)].bloq != 1 )
			{
				pathsight[i+(ii-1)][j+(jj-1)].list = 0;
				pathsight[i+(ii-1)][j+(jj-1)].parx = j;
				pathsight[i+(ii-1)][j+(jj-1)].pary = i;
				pathsight[i+(ii-1)][j+(jj-1)].G = abs((ii-1)*(jj-1));
				if (pathsight[i+(ii-1)][j+(jj-1)].G == 1) pathsight[i+(ii-1)][j+(jj-1)].G = 14;
				else pathsight[i+(ii-1)][j+(jj-1)].G = 10;
				pathsight[i+(ii-1)][j+(jj-1)].H =  10*(abs( (j+(jj-1))-alvox ) + abs( (i+(ii-1))-alvoy ) );
				pathsight[i+(ii-1)][j+(jj-1)].F = pathsight[i+(ii-1)][j+(jj-1)].G+pathsight[i+(ii-1)][j+(jj-1)].H;
			}

	pathsight[i][j].list = 1;

	// Move NPC with lame A* algorithm, no collision detection
	while ( pathsight[alvoy][alvox].list != 1 && count_list != 0)
	{
/////// TO PREVENT INFINITE LOOPZ WE ABORT IF FUNCTION TAKES TOO LONG
        Act_Tempo(); // for gambiarra fix
        if ( GAMBZ+2 < Tempo ) {

						for (ii=0;ii<=size_mapa-1;ii++)
							free (pathsight[ii]);
						free (pathsight); return; }
//////////////////////////////////////////////////////////// THIS REALLY SUX

			k=0; kk=10000;
			for (ii=0;ii<=size_mapa-2;ii++)
				for(jj=0;jj<=size_mapa-2;jj++)
				if (pathsight[ii][jj].list == 0 )
				{
					k = pathsight[ii][jj].F;
					if (k < kk && k != 0) kk = k;
				}

			k=0;
			for (ii=0;ii<=size_mapa-2&&k==0;ii++)
				for(jj=0;jj<=size_mapa-2&&k==0;jj++)
				if (pathsight[ii][jj].F == kk && pathsight[ii][jj].list == 0 )
				{
					i = ii; j = jj;
					if (i < 1 )
                        i = 1;
                    if (i > size_mapa-2)
                        i = size_mapa-2;
					if (j < 1 )
                        j = 1;
                    if (j > size_mapa-2)
                        j = size_mapa-2;
					pathsight[i][j].list = 1;
					k=1;
				}

			for (ii=0;ii<=2;ii++)
				for(jj=0;jj<=2;jj++)
				if (pathsight[i+(ii-1)][j+(jj-1)].bloq != 1 && pathsight[i+(ii-1)][j+(jj-1)].list != 1 )
				{
				if (pathsight[i+(ii-1)][j+(jj-1)].list == 0)
				{
					k = abs((ii-1)*(jj-1));
					if ( k == 0 ) k=10; else k=14;
					if (k+pathsight[i][j].G < pathsight[i+(ii-1)][j+(jj-1)].G)
					{
						pathsight[i+(ii-1)][j+(jj-1)].parx = j;
						pathsight[i+(ii-1)][j+(jj-1)].pary = i;

						if (abs((ii-1)*(jj-1)) == 0)
							pathsight[i+(ii-1)][j+(jj-1)].G = pathsight[pathsight[i+(ii-1)][j+(jj-1)].pary][pathsight[i+(ii-1)][j+(jj-1)].parx].G + 10;
						else pathsight[i+(ii-1)][j+(jj-1)].G = pathsight[pathsight[i+(ii-1)][j+(jj-1)].pary][pathsight[i+(ii-1)][j+(jj-1)].parx].G + 14;


						pathsight[i+(ii-1)][j+(jj-1)].F = pathsight[i+(ii-1)][j+(jj-1)].G+pathsight[i+(ii-1)][j+(jj-1)].H;
					}
				}
				if (pathsight[i+(ii-1)][j+(jj-1)].list == 2)
					{
					pathsight[i+(ii-1)][j+(jj-1)].parx = j;
					pathsight[i+(ii-1)][j+(jj-1)].pary = i;

					if ( abs((ii-1)*(jj-1)) == 0)
						pathsight[i+(ii-1)][j+(jj-1)].G = pathsight[pathsight[i+(ii-1)][j+(jj-1)].pary][pathsight[i+(ii-1)][j+(jj-1)].parx].G + 10;
					else pathsight[i+(ii-1)][j+(jj-1)].G = pathsight[pathsight[i+(ii-1)][j+(jj-1)].pary][pathsight[i+(ii-1)][j+(jj-1)].parx].G + 14;

					pathsight[i+(ii-1)][j+(jj-1)].H = 10*(abs( (j+(jj-1))-alvox ) + abs( (i+(ii-1))-alvoy ) );
					pathsight[i+(ii-1)][j+(jj-1)].F = pathsight[i+(ii-1)][j+(jj-1)].G+pathsight[i+(ii-1)][j+(jj-1)].H;
					pathsight[i+(ii-1)][j+(jj-1)].list = 0;
					}


				}

			count_list=0;
			for (ii=0; ii<=size_mapa-2;ii++)
				for (jj=0; jj<=size_mapa-2;jj++)
					if (pathsight[ii][jj].list == 0)
						count_list++;
			if ( count_list == 0 ) { //printf("Impossível traçar caminho para criatura.");

                                    Play_Snd("snd/alarm.wav");
                                    Digue("no route to path");
                                      meowvendo=0;
                                   if ( alvox-cartola[nn].x < 0 ) cartola[nn].sprite = 2;    //face LEFT
                                    if ( alvox-cartola[nn].x > 0 ) cartola[nn].sprite = 4; // face RIGHT
                                    if ( alvoy-cartola[nn].y < 0 ) cartola[nn].sprite = 0;    // face UP
                                    if ( alvoy-cartola[nn].y > 0 ) cartola[nn].sprite = 6;    //face down

						for (ii=0;ii<=size_mapa-1;ii++)
							free (pathsight[ii]);
						free (pathsight); return; }





	}

	kk=0; pathsight[i][j].N = n;
	ii = pathsight[i][j].pary; jj = pathsight[i][j].parx;

	while ( jj != cartola[nn].x || ii != cartola[nn].y )
	{
		n++;
		pathsight[pathsight[i][j].pary][pathsight[i][j].parx].N = n;
		ii = pathsight[i][j].pary; jj = pathsight[i][j].parx;
		i = ii; j = jj;

	}


	while (kk != 1)
	{



			k=0;kk=0;
			for ( ii=0; ii<=size_mapa-1; ii++)
				for (jj=0;jj<=size_mapa-1; jj++)
					if ( pathsight[ii][jj].N != 0 )
					{
						k = pathsight[ii][jj].N;
						if ( k > kk  ) kk = k;
					}
			i=0; j=0; k=0;
			for ( ii=0; ii<=size_mapa-1&&k==0; ii++)
				for (jj=0;jj<=size_mapa-1&&k==0; jj++)
					if ( pathsight[ii][jj].N == kk)
					{
						pathsight[ii][jj].N = 0;
						if (cartola[nn].x > jj) j = -1;
						if (cartola[nn].x == jj) j = 0;
						if (cartola[nn].x < jj) j = 1;
						if (cartola[nn].y > ii) i = -1;
						if (cartola[nn].y == ii) i = 0;
						if (cartola[nn].y < ii) i = 1;
						k=1;
					}

			while ( ( cartola[nn].x != jj-1 || cartola[nn].y != ii-1 ) && act_n && meowvendo < 3 )
			{

			Act_Tempo();
		if (tac.tic == 1)
            {



                if ( j < 0 ) cartola[nn].sprite = 2;    //face LEFT
				if ( j > 0 ) cartola[nn].sprite = 4; // face RIGHT
                if ( i > 0 ) cartola[nn].sprite = 0;    // face UP
				if ( i < 0 ) cartola[nn].sprite = 6;    //face down
            meowvendo++;
				cartola[nn].pxScr += STEP*(float)j;
				cartola[nn].pyScr += STEP*(float)i;

				if(cartola[nn].pxScr >= size_mapa-2) cartola[nn].pxScr = size_mapa-2;
				if(cartola[nn].pyScr >= size_mapa-2) cartola[nn].pyScr = size_mapa-2;
				if(cartola[nn].pxScr <= 1) cartola[nn].pxScr = 1;
				if(cartola[nn].pyScr <= 1) cartola[nn].pyScr = 1;

				if (modff(cartola[nn].pxScr, pcocozal) >= 0.75)
					cartola[nn].x = (int)ceilf(cartola[nn].pxScr);
				else cartola[nn].x = (int)floorf(cartola[nn].pxScr);
				if (modff(cartola[nn].pyScr, pcocozal) >= 0.75)
					cartola[nn].y = (int)ceilf(cartola[nn].pyScr);
				else cartola[nn].y = (int)floorf(cartola[nn].pyScr);


			Desenha_Tudo();
			   Atualiza_Tudo();
			Desenha_stats();
			Input_Teclado();

        SDL_RenderPresent(window_renderer);

                meowvendo--;

                }

            }



	} // while kk != 1

        meowvendo = 0;

	for (ii=0;ii<=size_mapa-1;ii++)
		free (pathsight[ii]);
	free (pathsight);

}

unsigned char Walk_NPCS(int alvox, int alvoy, int x, int y)
{
// delinquent implementation of Walk_NPC to move simultaneously

    unsigned long int GAMBZ = Tempo; // to prevent infinite loop

	struct pathfinder **pathsight;

	int i,j,ii,jj,n=2,nn,k,kk,count_list=1;
	float *pcocozal, cocozal;

	pcocozal = &cocozal;

	for(nn=1;nn<=(N_CARTOLA)-1;nn++)
		if (cartola[nn].inix == x && cartola[nn].iniy == y)
			break;

	i = cartola[nn].y; j=cartola[nn].x;

	pathsight = malloc(size_mapa*sizeof(struct pathfinder *));
	if ( pathsight == NULL ) printf("Erro alocando dados de pathfinding\n");
	for (ii=0; ii<=size_mapa-1; ii++)
	{
		pathsight[ii] = malloc(size_mapa*sizeof(struct pathfinder));
		if ( pathsight[ii] == NULL ) printf("Erro alocando dados de pathfinding\n");
	}

	for (ii=0; ii<=size_mapa-1; ii++)
		for (jj=0; jj<=size_mapa-1; jj++)
			{ pathsight[ii][jj].F = 0; pathsight[ii][jj].G = 0; pathsight[ii][jj].H = 0;
			pathsight[ii][jj].N = 0; pathsight[ii][jj].bloq = 0; pathsight[ii][jj].list = 2; }

	for (ii=0; ii<=size_mapa-1; ii++)
		for (jj=0; jj<=size_mapa-1; jj++)
			if ( mapa[ii][jj].obj != 0 )
				pathsight[ii][jj].bloq = 1;

	for (ii=0; ii<=size_mapa-1; ii++)
	{ pathsight[0][ii].bloq = 1; pathsight[size_mapa-2][ii].bloq = 1; }

	for (ii=0; ii<=size_mapa-1; ii++)
	{ pathsight[0][ii].bloq = 1; pathsight[size_mapa-2][ii].bloq = 1; }

	pathsight[i][j].list = 0;
	pathsight[i][j].parx = j;
	pathsight[i][j].pary = i;

	for (ii=0;ii<=2;ii++)
		for(jj=0;jj<=2;jj++)
			if (pathsight[i+(ii-1)][j+(jj-1)].bloq != 1 )
			{
				pathsight[i+(ii-1)][j+(jj-1)].list = 0;
				pathsight[i+(ii-1)][j+(jj-1)].parx = j;
				pathsight[i+(ii-1)][j+(jj-1)].pary = i;
				pathsight[i+(ii-1)][j+(jj-1)].G = abs((ii-1)*(jj-1));
				if (pathsight[i+(ii-1)][j+(jj-1)].G == 1) pathsight[i+(ii-1)][j+(jj-1)].G = 14;
				else pathsight[i+(ii-1)][j+(jj-1)].G = 10;
				pathsight[i+(ii-1)][j+(jj-1)].H =  10*(abs( (j+(jj-1))-alvox ) + abs( (i+(ii-1))-alvoy ) );
				pathsight[i+(ii-1)][j+(jj-1)].F = pathsight[i+(ii-1)][j+(jj-1)].G+pathsight[i+(ii-1)][j+(jj-1)].H;
			}

	pathsight[i][j].list = 1;

	// move NPCs with lame A* algorithm, no collision detection
	while ( pathsight[alvoy][alvox].list != 1 && count_list != 0)
	{
/////// TO PREVENT INFINITE LOOPZ WE ABORT IF LOOP TAKES TOO LONG
        Act_Tempo(); // for gambiarra fix
        if ( GAMBZ+2 < Tempo ) {

						for (ii=0;ii<=size_mapa-1;ii++)
							free (pathsight[ii]);
						free (pathsight); return 1; }
//////////////////////////////////////////////////////////// THIS REALLY SUX

			k=0; kk=1000000;
			for (ii=0;ii<=size_mapa-2;ii++)
				for(jj=0;jj<=size_mapa-2;jj++)
				if (pathsight[ii][jj].list == 0 )
				{
					k = pathsight[ii][jj].F;
					if (k < kk && k != 0)
                        kk = k;
				}

			k=0;
			for (ii=0;ii<=size_mapa-2&&k==0;ii++)
				for(jj=0;jj<=size_mapa-2&&k==0;jj++)
				if (pathsight[ii][jj].F == kk && pathsight[ii][jj].list == 0 )
				{
					i = ii; j = jj;
					if (i < 1 )
                        i = 1;
                    if (i > size_mapa-2)
                        i = size_mapa-2;
					if (j < 1 )
                        j = 1;
                    if (j > size_mapa-2)
                        j = size_mapa-2;
					pathsight[i][j].list = 1;
					k=1;
				}

			for (ii=0;ii<=2;ii++)
				for(jj=0;jj<=2;jj++)
				if (pathsight[i+(ii-1)][j+(jj-1)].bloq != 1 && pathsight[i+(ii-1)][j+(jj-1)].list != 1 )
				{
				if (pathsight[i+(ii-1)][j+(jj-1)].list == 0)
				{
					k = abs((ii-1)*(jj-1));
					if ( k == 0 ) k=10; else k=14;
					if (k+pathsight[i][j].G < pathsight[i+(ii-1)][j+(jj-1)].G)
					{
						pathsight[i+(ii-1)][j+(jj-1)].parx = j;
						pathsight[i+(ii-1)][j+(jj-1)].pary = i;

						if (abs((ii-1)*(jj-1)) == 0)
							pathsight[i+(ii-1)][j+(jj-1)].G = pathsight[pathsight[i+(ii-1)][j+(jj-1)].pary][pathsight[i+(ii-1)][j+(jj-1)].parx].G + 10;
						else pathsight[i+(ii-1)][j+(jj-1)].G = pathsight[pathsight[i+(ii-1)][j+(jj-1)].pary][pathsight[i+(ii-1)][j+(jj-1)].parx].G + 14;


						pathsight[i+(ii-1)][j+(jj-1)].F = pathsight[i+(ii-1)][j+(jj-1)].G+pathsight[i+(ii-1)][j+(jj-1)].H;
					}
				}
				if (pathsight[i+(ii-1)][j+(jj-1)].list == 2)
					{
					pathsight[i+(ii-1)][j+(jj-1)].parx = j;
					pathsight[i+(ii-1)][j+(jj-1)].pary = i;

					if ( abs((ii-1)*(jj-1)) == 0)
						pathsight[i+(ii-1)][j+(jj-1)].G = pathsight[pathsight[i+(ii-1)][j+(jj-1)].pary][pathsight[i+(ii-1)][j+(jj-1)].parx].G + 10;
					else pathsight[i+(ii-1)][j+(jj-1)].G = pathsight[pathsight[i+(ii-1)][j+(jj-1)].pary][pathsight[i+(ii-1)][j+(jj-1)].parx].G + 14;

					pathsight[i+(ii-1)][j+(jj-1)].H = 10*(abs( (j+(jj-1))-alvox ) + abs( (i+(ii-1))-alvoy ) );
					pathsight[i+(ii-1)][j+(jj-1)].F = pathsight[i+(ii-1)][j+(jj-1)].G+pathsight[i+(ii-1)][j+(jj-1)].H;
					pathsight[i+(ii-1)][j+(jj-1)].list = 0;
					}


				}

			count_list=0;
			for (ii=0; ii<=size_mapa-2;ii++)
				for (jj=0; jj<=size_mapa-2;jj++)
					if (pathsight[ii][jj].list == 0)
						count_list++;
			if ( count_list == 0 ) { //printf("Impossível traçar caminho para criatura.");
						for (ii=0;ii<=size_mapa-1;ii++)
							free (pathsight[ii]);
						free (pathsight); return 0; }





	}

	kk=0; pathsight[i][j].N = n;
	ii = pathsight[i][j].pary; jj = pathsight[i][j].parx;

	while ( jj != cartola[nn].x || ii != cartola[nn].y )
	{
		n++;
		pathsight[pathsight[i][j].pary][pathsight[i][j].parx].N = n;
		ii = pathsight[i][j].pary; jj = pathsight[i][j].parx;
		i = ii; j = jj;

	}


	while (kk != n-1 && kk != 2)
	{


			k=0;kk=0;
			for ( ii=0; ii<=size_mapa-1; ii++)
				for (jj=0;jj<=size_mapa-1; jj++)
					if ( pathsight[ii][jj].N != 0 )
					{
						k = pathsight[ii][jj].N;
						if ( k > kk  )
                            kk = k;
					}
			i=0; j=0; k=0;
			for ( ii=0; ii<=size_mapa-1&&k==0; ii++)
				for (jj=0;jj<=size_mapa-1&&k==0; jj++)
					if ( pathsight[ii][jj].N == kk)
					{
						pathsight[ii][jj].N = 0;
						if (cartola[nn].x > jj)
                            j = -1;
						if (cartola[nn].x == jj)
                            j = 0;
						if (cartola[nn].x < jj)
                            j = 1;
						if (cartola[nn].y > ii)
                            i = -1;
						if (cartola[nn].y == ii)
                            i = 0;
						if (cartola[nn].y < ii)
                            i = 1;
						k=1;
					}

				cartola[nn].pxScr += STEP*(float)j;
				cartola[nn].pyScr += STEP*(float)i;

				if(cartola[nn].pxScr >= size_mapa-2)
                    cartola[nn].pxScr = size_mapa-2;
				if(cartola[nn].pyScr >= size_mapa-2)
                    cartola[nn].pyScr = size_mapa-2;
				if(cartola[nn].pxScr <= 1)
                    cartola[nn].pxScr = 1;
				if(cartola[nn].pyScr <= 1)
                    cartola[nn].pyScr = 1;

				if (modff(cartola[nn].pxScr, pcocozal) >= 0.75)
					cartola[nn].x = (int)ceilf(cartola[nn].pxScr);
				else cartola[nn].x = (int)floorf(cartola[nn].pxScr);
				if (modff(cartola[nn].pyScr, pcocozal) >= 0.75)
					cartola[nn].y = (int)ceilf(cartola[nn].pyScr);
				else cartola[nn].y = (int)floorf(cartola[nn].pyScr);


	} // while kk != n-1

	for (ii=0;ii<=size_mapa-1;ii++)
		free (pathsight[ii]);
	free (pathsight);

	if ( cartola[nn].x == alvox && cartola[nn].y == alvoy ) return 0; else return 1;

}


int Walk_Party(float falvox, float falvoy, int nn)
{
// This function moves a party member i, as of party[i], targeted at (alvox, alvoy)
// using a delinquent implementation of A* algorithm
// there are several triggers to abort and avoid too much recursion
// but sometimes it breaks

    unsigned long int GAMBZ = Tempo; // to prevent infinite loop

	struct pathfinder **pathsight;
	struct pathlista *pathlist;

	int i,j,ii,jj,n=1,k,kk,count_list=1,n_lista=0,alvox,alvoy;
	float *pcocozal, cocozal;

	pcocozal = &cocozal;

	i = party[nn].y; j=party[nn].x;
	if (falvox > size_mapa-1)
        falvox = size_mapa-1;
    if (falvoy > size_mapa-1)
        falvoy = size_mapa-1;
    if (falvox < 0)
        falvox = 0;
    if (falvoy < 0)
        falvoy = 0;

    alvox = (int)(falvox);
    alvoy = (int)(falvoy);

	if (modff(falvox, pcocozal) >= 0.55)
		alvox = (int)ceilf(falvox);
	else alvox = (int)floorf(falvox);
	if (modff(falvoy, pcocozal) >= 0.55)
		alvoy = (int)ceilf(falvoy);
	else alvoy = (int)floorf(falvoy);

       if ( mapa[alvoy][alvox].obj || !party[nn].partykey )
        {
            //Digue("invalid pathfinding target");


            return 1; }



	pathlist = malloc(size_mapa*size_mapa*sizeof(struct pathlista));
	if ( pathlist == NULL ) printf("Err alloc player pathfinding list\n");

	pathsight = malloc(size_mapa*sizeof(struct pathfinder *));
	 if ( pathsight == NULL ) printf("Erro alloc player pathfinding\n");
	 for (ii=0; ii<=size_mapa-1; ii++)
        {
		pathsight[ii] = malloc(size_mapa*sizeof(struct pathfinder));
		if ( pathsight[ii] == NULL ) printf("Err alloc player pathfinding[][]\n");
        }

	for (ii=0; ii<=size_mapa-1; ii++)
		for (jj=0; jj<=size_mapa-1; jj++)
			{ pathsight[ii][jj].F = 0; pathsight[ii][jj].G = 0; pathsight[ii][jj].H = 0;
			pathsight[ii][jj].N = 0; pathsight[ii][jj].bloq = 0; pathsight[ii][jj].list = 2;

			if ( mapa[ii][jj].obj )
				pathsight[ii][jj].bloq = 1;


			}

	pathsight[i][j].list = 0;
	pathsight[i][j].parx = j;
	pathsight[i][j].pary = i;

	for (ii=0;ii<=2;ii++)
		for(jj=0;jj<=2;jj++)
			if ( i+(ii-1) >= 0 && i+(ii-1) <= size_mapa-1 && j+(jj-1) >= 0 && j+(jj-1) <= size_mapa-1)
			if (pathsight[i+(ii-1)][j+(jj-1)].bloq != 1 )
			{
				n_lista++;
				pathsight[i+(ii-1)][j+(jj-1)].list = 0;
				pathlist[n_lista].x = j+(jj-1); pathlist[n_lista].y = i+(ii-1);
				pathsight[i+(ii-1)][j+(jj-1)].parx = j;
				pathsight[i+(ii-1)][j+(jj-1)].pary = i;
				pathsight[i+(ii-1)][j+(jj-1)].G = abs((ii-1)*(jj-1));
				if (pathsight[i+(ii-1)][j+(jj-1)].G == 1) pathsight[i+(ii-1)][j+(jj-1)].G = 14;
				else pathsight[i+(ii-1)][j+(jj-1)].G = 10;
				pathsight[i+(ii-1)][j+(jj-1)].H =  10*(abs( (j+(jj-1))-alvox ) + abs( (i+(ii-1))-alvoy ) );
				pathsight[i+(ii-1)][j+(jj-1)].F = pathsight[i+(ii-1)][j+(jj-1)].G+pathsight[i+(ii-1)][j+(jj-1)].H;
			}

	pathsight[i][j].list = 1;
	pathlist[0].x = j; pathlist[0].y = i;

	// Move party member with lame A* algorithm, no collision detection
	while ( pathsight[alvoy][alvox].list != 1 && count_list >= 1)
	{

/////// TO PREVENT INFINITE LOOPZ WE ABORT IF FUNCTION TAKES TOO LONG
        Act_Tempo(); // for gambiarra fix
        if ( GAMBZ+2 < Tempo ) {

						for (ii=0;ii<=size_mapa-1;ii++)
							free (pathsight[ii]);
						free (pathsight); return 1; }
//////////////////////////////////////////////////////////// THIS REALLY SUX

			k=0; kk=1000000;
			for (ii=0;ii<=n_lista;ii++)
			{
				k = pathsight[pathlist[ii].y][pathlist[ii].x].F;
				if (k < kk && k != 0) kk = k;
			}

			for (ii=0;ii<=n_lista;ii++)
				if (pathsight[pathlist[ii].y][pathlist[ii].x].F == kk)
				{
					i = pathlist[ii].y; j = pathlist[ii].x;
					pathsight[i][j].list = 1;
					for (jj=0;jj<=n_lista;jj++)
					if ( jj > ii )
					{
						pathlist[ii].x = pathlist[jj].x;
						pathlist[ii].y = pathlist[jj].y;
						ii++;
					}
					n_lista--;
					break;
				}

			for (ii=0;ii<=2;ii++)
				for(jj=0;jj<=2;jj++)
				if ( i+(ii-1) >= 0 && i+(ii-1) <= size_mapa-1 && j+(jj-1) >= 0 && j+(jj-1) <= size_mapa-1)
				if (pathsight[i+(ii-1)][j+(jj-1)].bloq != 1 && pathsight[i+(ii-1)][j+(jj-1)].list != 1 )
				{
				if (pathsight[i+(ii-1)][j+(jj-1)].list == 0)
				{
					k = abs((ii-1)*(jj-1));
					if ( k == 0 ) k=10; else k=14;
					if (k+pathsight[i][j].G < pathsight[i+(ii-1)][j+(jj-1)].G)
					{
						pathsight[i+(ii-1)][j+(jj-1)].parx = j;
						pathsight[i+(ii-1)][j+(jj-1)].pary = i;

						if (abs((ii-1)*(jj-1)) == 0)
							pathsight[i+(ii-1)][j+(jj-1)].G = pathsight[pathsight[i+(ii-1)][j+(jj-1)].pary][pathsight[i+(ii-1)][j+(jj-1)].parx].G + 10;
						else pathsight[i+(ii-1)][j+(jj-1)].G = pathsight[pathsight[i+(ii-1)][j+(jj-1)].pary][pathsight[i+(ii-1)][j+(jj-1)].parx].G + 14;


						pathsight[i+(ii-1)][j+(jj-1)].F = pathsight[i+(ii-1)][j+(jj-1)].G+pathsight[i+(ii-1)][j+(jj-1)].H;
					}
				}
				if (pathsight[i+(ii-1)][j+(jj-1)].list == 2)
					{
					pathsight[i+(ii-1)][j+(jj-1)].parx = j;
					pathsight[i+(ii-1)][j+(jj-1)].pary = i;

					if ( abs((ii-1)*(jj-1)) == 0)
						pathsight[i+(ii-1)][j+(jj-1)].G = pathsight[pathsight[i+(ii-1)][j+(jj-1)].pary][pathsight[i+(ii-1)][j+(jj-1)].parx].G + 10;
					else pathsight[i+(ii-1)][j+(jj-1)].G = pathsight[pathsight[i+(ii-1)][j+(jj-1)].pary][pathsight[i+(ii-1)][j+(jj-1)].parx].G + 14;

					pathsight[i+(ii-1)][j+(jj-1)].H = 10*(abs( (j+(jj-1))-alvox ) + abs( (i+(ii-1))-alvoy ) );
					pathsight[i+(ii-1)][j+(jj-1)].F = pathsight[i+(ii-1)][j+(jj-1)].G+pathsight[i+(ii-1)][j+(jj-1)].H;
					pathsight[i+(ii-1)][j+(jj-1)].list = 0;
					n_lista++;
					pathlist[n_lista].x = j+(jj-1); pathlist[n_lista].y = i+(ii-1);
					}


				}

			count_list=0;
			for (ii=0; ii<n_lista;ii++)
					count_list++;
			if ( count_list == 0 ) { //printf("Impossível traçar caminho para membro da caravana.");
						party[nn].walkable = 0;

						for (ii=0;ii<=size_mapa-1;ii++)
							free (pathsight[ii]);
						free (pathsight);
						free(pathlist); return 1; }





	}

	kk=0; pathsight[i][j].N = n;
	ii = pathsight[i][j].pary; jj = pathsight[i][j].parx;

	while ( jj != party[nn].x || ii != party[nn].y )
	{
		ii = pathsight[i][j].pary; jj = pathsight[i][j].parx;
		if ( party[nn].x != jj || party[nn].y != ii ) { i = ii; j = jj; }

	}

	if (party[nn].x > j) { j = -1; party[nn].sprite = 2; }
	if (party[nn].x == j) j = 0;
	if (party[nn].x < j) { j = 1; party[nn].sprite = 4; }
	if (party[nn].y > i) { i = -1; party[nn].sprite = 6; }
	if (party[nn].y == i) i = 0;
	if (party[nn].y < i) { i = 1; party[nn].sprite = 0; }



	party[nn].pxScr += (STEP*(float)j)+(rand()%3)*0.025;
	party[nn].pyScr += (STEP*(float)i)+(rand()%3)*0.025;

	if(party[nn].pxScr > size_mapa-1) party[nn].pxScr = size_mapa-1;
	if(party[nn].pyScr > size_mapa-1) party[nn].pyScr = size_mapa-1;
	if(party[nn].pxScr < 0) party[nn].pxScr = 0;
	if(party[nn].pyScr < 0) party[nn].pyScr = 0;

	if (modff(party[nn].pxScr, pcocozal) >= 0.75)
		party[nn].x = (int)ceilf(party[nn].pxScr);
	else party[nn].x = (int)floorf(party[nn].pxScr);
	if (modff(party[nn].pyScr, pcocozal) >= 0.75)
		party[nn].y = (int)ceilf(party[nn].pyScr);
	else party[nn].y = (int)floorf(party[nn].pyScr);

	for (ii=0;ii<=size_mapa-1;ii++)
		free (pathsight[ii]);
	free (pathsight);
	free(pathlist);


    return 0;

}

int Pega_item(int k, unsigned char n)
{
// This function removes cartola struct member index k, as of cartola[k]
// transform into item as of item[n-60], where n is item "tipo"
// It returns 1 if inventory is full

	int x, cheio=1;
	char msg[500];


	for (x=0;x<NBAG;x++)
		if (inventory[x].tipo == 0 && !pegado)
		{
			cheio = 0;
			inventory[x].tipo = item[n-60].tipo;
			strcpy(inventory[x].nome, item[n-60].nome);
			inventory[x].valor = item[n-60].valor;
			if ( k != -1 ) {
                    cartola[k].camada = 0;
					cartola[k].tipo = 0;
					cartola[k].select = 0;
					if ( PALLANTIR == k )
                        PALLANTIR = 0;
					cartola[k].flag = 0;

					cartola[k].inix = 0;
                    cartola[k].iniy = 0;
                    cartola[k].x = 0;
                    cartola[k].y = 0;
                    cartola[k].pxScr = 0;
                    cartola[k].pyScr = 0;

            }

			sprintf(msg, "Pegou (%d) %s.", x, item[n-60].nome);
			Play_Snd("snd/gotcha.wav");
			Digue(msg);
			/* if ( DESBUG )
                Digue_Window(msg); */
                pegado = 1;

            break;
		}
	if ( cheio == 1 && !pegado ) { pegado = 1; Digue("Mochila cheia."); return 1; }


	return 0;
}

void Give_Item(int n, int inix, int iniy)
{
// This function tryes to insert item "tipo" n into inventory
// if fails try to spawn near player pos
// creating entity at next free cartola[k]
	int k, kk;
	char msg[500];
				if ( (Pega_item(-1, n)) == 1)
					for (k=1;k<=(N_CARTOLA)-1;k++)
						if (cartola[k].camada == 0)
						{
							kk = 0;
							do {
								kk++;
								if (EGO.y+kk >= size_mapa-2 || EGO.x+kk >= size_mapa-2)
									{ printf("*ERRO* ñ pode criar item\n");
									  Digue("*ERRO* Nao pode criar item. Abortando função!");
									  mapa[iniy][inix].flag = 0; return;  }
							} while ( (mapa[EGO.y+kk][EGO.x+kk].obj != 0 && mapa[EGO.y+kk][EGO.x+kk].flag != 0) && EGO.y+kk<=size_mapa-2&&EGO.x+kk<=size_mapa-2 );
							cartola[k].camada = 1;
							cartola[k].tipo = n;
							cartola[k].inix = EGO.x+kk;
							cartola[k].iniy = EGO.y+kk;
							cartola[k].x = EGO.x+kk;
							cartola[k].y = EGO.y+kk;
							cartola[k].pxScr = (float)(EGO.x+kk);
							cartola[k].pyScr = (float)(EGO.y+kk);
							//cartola[k].hp = Livro[n].hp;
							cartola[k].flag = n;
							cartola[k].vivo = 0;
							cartola[k].sprite = 0;

							sprintf(msg, "Surgiu %s", item[n-60].nome);
							Digue(msg);
							return;
						}

}

void HasItem(int x)
{
// This function must be used with "If" clause in T4c scripts
//  It tests if inventory has an item "tipo" = x
	int k;

	resultCondition = 0;
	for (k=0;k<NBAG;k++)
		if (inventory[k].tipo == x)
		{ resultCondition=1; break; }

}

void HasParty(int x)
{
// This function must be used with "If" clause in T4c scripts
//  It tests if party has an member "tipo" = x
	int i;
	resultCondition = 0;
	for (i=1; i<=NTRUPY; i++)
		if (party[i].tipo == x)
		{ resultCondition=1; break; }
}

void HasSelect(int x)
{
// This function must be used with "If" clause in T4c scripts
//  It checks last SelectOpts function "selected" value
	resultCondition = 0;
	if (selected == x)
		resultCondition=1;

}

void HasGold(int x)
{
// This function must be used with "If" clause in T4c scripts
//  It tests quantity of EGO.gold > x
	resultCondition = 0;
	if ( EGO.gold >= x)
		resultCondition=1;

}
void HasWood(int x)
{
// This function must be used with "If" clause in T4c scripts
//  It tests quantity of EGO.wood > x
	resultCondition = 0;
	if ( EGO.wood >= x)
		resultCondition=1;

}
void Give_Wood(int x)
{
// This function increases EGO.wood by += x
	EGO.wood+=x;
	if (EGO.wood < 0) EGO.wood = 0;
}
void Give_Gold(int x)
{
// This function increases EGO.gold by += x
	EGO.gold+=x;
	if (EGO.gold < 0) EGO.gold = 0;
}

void Give_Xp(int x)
{
// This function increases EGO.xp by += x
	EGO.xp+=x;
	if (EGO.xp < 0) EGO.xp = 0;
}

void Give_Hp(int x)
{
// This function increases EGO.hp by += x
        EGO.hp+=x;
	if (EGO.hp > EGO.hpmax) EGO.hp = EGO.hpmax;
}

void Create_Item(int n, int alvox, int alvoy)
{
// This function spawns an item "tipo" n
// and inserts into Cartola struct at (alvox,alvoy)
// or, if alvox negative, random spawn at abs(alvox)+alvoy distance
	int k;
	char msg[250];

	for (k=1;k<=(N_CARTOLA)-1;k++)
		if (cartola[k].camada == 0)
		{
				if ( alvoy >= size_mapa-2 || alvox >= size_mapa-2)
				{ Digue("*ERRO* Nao pode criar item. Abortando função!");
				  mapa[iniy][inix].flag = 0; return; }
				cartola[k].camada = 1;
				cartola[k].tipo = n;
				if ( alvox >= 0 ) {
                    cartola[k].inix = alvox;
                    cartola[k].iniy = alvoy;
                    cartola[k].x = alvox;
                    cartola[k].y = alvoy;
                    cartola[k].pxScr = (float)(alvox);
                    cartola[k].pyScr = (float)(alvoy);

                    mapa[alvoy][alvox].obj = 0;

                } else {
                    cartola[k].inix = EGO.x+(rand()%(abs(alvox)+alvoy));
                    cartola[k].iniy = 1+EGO.y+(rand()%(abs(alvox)+alvoy));
                    cartola[k].x = cartola[k].inix;
                    cartola[k].y = cartola[k].iniy;
                    cartola[k].pxScr = (float)(cartola[k].inix);
                    cartola[k].pyScr = (float)(cartola[k].iniy);

                    mapa[cartola[k].y][cartola[k].x].obj = 0;

                }

                 strcpy(cartola[k].id, item[n-60].nome);

               	cartola[k].hpmax = 1; //Livro[n].hp;
               	cartola[k].hp = cartola[k].hpmax;
				cartola[k].flag = n;
				cartola[k].vivo = 0;
				cartola[k].sprite = 0;
//				mapa[alvoy+kk][alvox+kk].obj = 13;

				sprintf(msg, "Surgiu %s", item[n-60].nome);
				Digue(msg);
				break;
		}

}

void Destroy_Item(int n, int jj)
{
// This function removes an item "tipo" n from inventory;
	char msg[500];
	int ii;

	for (ii=0;ii<NBAG;ii++)
		if (inventory[ii].tipo == n )
		{
			sprintf(msg, "Perdeu %s", inventory[ii].nome);
			Digue(msg);
			if ( DESBUG )
                Digue_Window(msg);
			inventory[ii].tipo = 0;
			inventory[ii].valor = 0;
			strcpy(inventory[ii].nome, "nada");
			break;
		}

}

void Create_NPC(const char idT[], int n, int qty, int nivel, int alvox, int alvoy, int nflag, const char wERK[])
{
// This function spawns an entity of "tipo" n and quantity qty.
// and inserts into Cartola struct at (alvox,alvoy)
// or, if alvox negative, random spawn at abs(alvox)+alvoy distance
// ex:  Create_NPC("camponeses",20,3,1,-6,-1,-9,"woodchucker")
// -----------------"idT",tipo,qty,level,alvox,alvoy,nflag,"wERK")
// nFlag sets .flag value if positive
// if negative nflag corresponds to "wERK" block on T4c script
// which is activated when NPC reaches an .obj with index abs(nflag)

	int ii,k;
        int randux = -1*((-1*(rand()%(abs(alvox)+alvoy))));
        int randuy = -1*((-1*(rand()%(abs(alvox)+alvoy))));

         if ( alvox < 0 ) {
            if ( EGO.x+1+(randux) >= 0 && EGO.y+(randux) >= 0 \
                && EGO.x+1+(randux) < size_mapa && EGO.y+(randux) < size_mapa )  {
                alvox = EGO.x+1+(randux);
                alvoy = EGO.y+1+randuy;
            } else {
                    alvox = EGO.x;
                    alvoy = EGO.y;
                }
        }

        if ( mapa[alvoy][alvox].obj != 0 )
            mapa[alvoy][alvox].obj = 0;

	for (ii=1;ii<=qty;ii++) {
		for (k=1;k<=(N_CARTOLA)-1;k++)
			if (cartola[k].camada == 0)
			{

				cartola[k].camada = 3;
			  	strcpy(cartola[k].id, idT);
			  	strcpy(cartola[k].werk, wERK);
				cartola[k].tipo = n;
				cartola[k].inix = alvox;
				cartola[k].iniy = alvoy;
				cartola[k].x = alvox;
				cartola[k].y = alvoy;
				cartola[k].pxScr = (float)alvox;
				cartola[k].pyScr = (float)alvoy;
				cartola[k].nivel = nivel;
				cartola[k].hpmax = Livro[n].hp+(nivel*5);
				cartola[k].hp = cartola[k].hpmax;
				cartola[k].vivo = 1;
				cartola[k].sprite = 0;
				cartola[k].Cronos = 0;
				cartola[k].Trigger = 0;
				cartola[k].select = 0;
				if ( PALLANTIR == k )
                        PALLANTIR = 0;
			     if ( nflag == -1 ) {	cartola[k].hostile = 1; cartola[k].flag = 0; }
			     else
				cartola[k].flag = nflag;
			break;
			}

	if (k >= (N_CARTOLA)-1)
	{
		Digue_Window("Estrutura de dados esgotada: criaturas mortas serão removidas do mapa.");
		for (k=1;k<=(N_CARTOLA)-1;k++)
			if (cartola[k].camada == 3 && cartola[k].vivo == 0)
			{
				strcpy(cartola[k].id, "");
				strcpy(cartola[k].werk, "");
				cartola[k].camada = 0;
				cartola[k].tipo = 0;
				cartola[k].x = 0;
				cartola[k].y = 0;
				cartola[k].pxScr = 0;
				cartola[k].pyScr = 0;
				cartola[k].hp = 0;
				cartola[k].hpmax = 0;
				cartola[k].nivel = 0;
				cartola[k].sprite = 0;
				cartola[k].flag = 0;
				cartola[k].inix = 0;
				cartola[k].iniy = 0;
				cartola[k].vivo = 0;
				cartola[k].Cronos = 0;
				cartola[k].Trigger = 0;
				cartola[k].hostile = 0;
				cartola[k].select = 0;
				if ( PALLANTIR == k )
                        PALLANTIR = 0;
			}
	   }
	}

}

void Destroy_NPC(int alvox, int alvoy)
{
// This function removes existence of NPC if at (alvox,alvoy)
	int n;

	for (n=1;n<=(N_CARTOLA)-1;n++)
		if (cartola[n].inix == alvox && cartola[n].iniy == alvoy)
		{
			strcpy(cartola[n].id, "");
			strcpy(cartola[n].werk, "");
			cartola[n].camada = 0;
			cartola[n].tipo = 0;
			cartola[n].x = 0;
			cartola[n].y = 0;
			cartola[n].pxScr = 0;
			cartola[n].pyScr = 0;
			cartola[n].hp = 0;
			cartola[n].nivel = 0;
			cartola[n].sprite = 0;
			cartola[n].flag = 0;
			cartola[n].inix = 0;
			cartola[n].iniy = 0;
			cartola[n].vivo = 0;
			cartola[n].hostile = 0;
			cartola[n].select = 0;
			break;
		}

}

void Kill_NPC(int alvox, int alvoy)
{
// This function makes NPC at (alvox,alvoy) die, leaving corpse
	int n;

	for (n=1;n<=(N_CARTOLA)-1;n++)
		if (cartola[n].inix == alvox && cartola[n].iniy == alvoy)
		{
			cartola[n].sprite = 10;
			cartola[n].vivo = 0;
			break;
		}

}

void Change_Flag(int x, int alvomapa, int alvox, int alvoy, int mapa_atual)
{
// This function changes existing flag
// (?) maybe not necessary anymore
	int k;

	if ( alvomapa == mapa_atual )
	{
		for (k=1; k<=(N_CARTOLA)-1; k++)
			if ( cartola[k].inix == alvox && cartola[k].iniy == alvoy )
				cartola[k].flag = x;
	}
	else { // search it on another map and alter it there
		if (Grava_Cache_Atual(mapa_atual) == 1) printf("PROBLEM WRITING CACHE while Change_Flag()\n");
		if (Retoma_Cache(alvomapa, mapa_atual) == 1) printf("PROBLEM READING CACHE while Change_Flag()\n");
		size_mapa = map_offsets[alvomapa];
		for (k=1; k<=(N_CARTOLA)-1; k++)
			if ( cartola[k].inix == alvox && cartola[k].iniy == alvoy )
				cartola[k].flag = x;
		if (Grava_Cache_Atual(alvomapa) == 1) printf("ERROR WRITING CACHE while Change_Flag()\n");
		if (Retoma_Cache(mapa_atual, alvomapa) == 1) printf("ERROR READING CACHE while Change_Flag()\n");
		size_mapa = map_offsets[mapa_atual];

	}


}

void Create_Flag(int x, int alvomapa, int alvox, int alvoy, int mapa_atual, const char idT[])
{
// This function creates a flag value "x" at (alvox,alvoy) on map "alvomapa" with id=idT
	int k;

	if ( alvomapa == mapa_atual )
	{
		for (k=1; k<=(N_CARTOLA)-1; k++)
			if ( cartola[k].camada == 0 )
			{
				cartola[k].inix = alvox;
				cartola[k].iniy = alvoy;
				cartola[k].x = alvox;
				cartola[k].y = alvoy;
				cartola[k].pxScr = (float) alvox;
				cartola[k].pyScr = (float) alvoy;
				cartola[k].camada = 5;
				cartola[k].flag = x;
				mapa[alvoy][alvox].flag = x;
				if ( strcmp("", idT)!=0 )
					strcpy(cartola[k].id, idT);
				break;
			}
	}
	else { // else search other map on cache and change flag there
		if (Grava_Cache_Atual(mapa_atual) == 1) printf("PROBLEM WRITING CACHE while Create_Flag()\n");
		if (Retoma_Cache(alvomapa, mapa_atual) == 1) printf("PROBLEM READING CACHE while Create_Flag()\n");
		size_mapa = map_offsets[alvomapa];
		for (k=1; k<=(N_CARTOLA)-1; k++)
			if ( cartola[k].camada == 0 )
			{
				cartola[k].inix = alvox;
				cartola[k].iniy = alvoy;
				cartola[k].x = alvox;
				cartola[k].y = alvoy;
				cartola[k].pxScr = (float) alvox;
				cartola[k].pyScr = (float) alvoy;
				cartola[k].camada = 5;
				cartola[k].flag = x;
				mapa[alvoy][alvox].flag = x;
				if ( strcmp("", idT) != 0 )
					strcpy(cartola[k].id, idT);
              	break;
			}
		if (Grava_Cache_Atual(alvomapa) == 1) printf("ERROR WRITING CACHE while Create_Flag()\n");
		if (Retoma_Cache(mapa_atual, alvomapa) == 1) printf("ERROR READING CACHE while Create_Flag()\n");
		size_mapa = map_offsets[mapa_atual];

	}


}

void Destroy_Flag(int alvomapa, int alvox, int alvoy, int mapa_atual)
{
// This function disables flag at (alvox,alvoy) of map="alvomapa"
	int k;

	if ( alvomapa == mapa_atual )
	{
		for (k=1; k<=(N_CARTOLA)-1; k++)
			if ( cartola[k].inix == alvox && cartola[k].iniy == alvoy)
			{
				if ( cartola[k].camada == 5 )
				{
					cartola[k].inix = 0;
					cartola[k].iniy = 0;
					cartola[k].camada = 0;
					cartola[k].flag = 0;
				}
				if ( cartola[k].camada == 3 )
					cartola[k].flag = 0;
			}
		mapa[alvoy][alvox].flag = 0;
	}
	else { // search other map and alter there
		if (Grava_Cache_Atual(mapa_atual) == 1) printf("ERROR WRITING CACHE while Destroy_Flag()\n");
		if (Retoma_Cache(alvomapa, mapa_atual) == 1) printf("ERROR READING CACHE while Destroy_Flag()\n");
		size_mapa = map_offsets[alvomapa];
		for (k=1; k<=(N_CARTOLA)-1; k++)
			if ( cartola[k].inix == alvox && cartola[k].iniy == alvoy)
			{
				if ( cartola[k].camada == 5 )
				{
					cartola[k].inix = 0;
					cartola[k].iniy = 0;
					cartola[k].camada = 0;
					cartola[k].flag = 0;
				}
				if ( cartola[k].camada == 3 )
					cartola[k].flag = 0;

			}
		mapa[alvoy][alvox].flag = 0;
		if (Grava_Cache_Atual(alvomapa) == 1) printf("ERROR WRITING CACHE while Destroy_Flag()\n");
		if (Retoma_Cache(mapa_atual, alvomapa) == 1) printf("ERROR READING CACHE while Destroy_Flag()\n");
		size_mapa = map_offsets[mapa_atual];

	}


}

void Select_Opt ( int x, char **selectoptions )
{
// This function creates a menu with "x" number of options,
// followed by each string opt separated by commas
// example, on T4c script: Select(3,"Opt1","Opt2","Opt3")

	int k, lido=0, cursorY=0;

	while (lido != 1)
  {
	src.x = 0; src.y =0; dest.x = 220; dest.y = 150;
	src.w = 135; dest.w = 135; src.h = 220; dest.h = 220;

	SDL_RenderCopy(window_renderer, cxatxt, &src, &dest);

	src.x = 5; src.y =0; dest.x = 355; dest.y = 150;
	src.w = 135; dest.w = 135; src.h = 220; dest.h = 220;

	SDL_RenderCopy(window_renderer, cxatxt, &src, &dest);


	if (cursorY > x-1)
            cursorY = x-1;
    if (cursorY < 0)
            cursorY = 0;

	texto=TTF_RenderUTF8_Solid(bigfont, "->", COR);

	dest.x = 235; dest.y = 160+((cursorY%x)*20);

		textexto = SDL_CreateTextureFromSurface(window_renderer, texto);

     TTF_SizeText(bigfont, "->", &w, &h);
                    dest.w = w;
                    dest.h = h;
	SDL_RenderCopy(window_renderer, textexto, NULL, &dest);


	SDL_FreeSurface(texto); SDL_DestroyTexture(textexto); textexto = NULL;
	texto = NULL;

for (k=0; k<=x-1; k++)
{
	texto=TTF_RenderUTF8_Solid(bigfont, selectoptions[k], CORv);
	dest.x = 250;
	dest.y = 160+(k*20);

		textexto = SDL_CreateTextureFromSurface(window_renderer, texto);

         TTF_SizeText(bigfont, selectoptions[k], &w, &h);
                    dest.w = w;
                    dest.h = h;
	SDL_RenderCopy(window_renderer, textexto, NULL, &dest);


	SDL_FreeSurface(texto); SDL_DestroyTexture(textexto); textexto = NULL;
	texto = NULL;
}

	SDL_RenderPresent(window_renderer);


	SDL_WaitEvent(&Evento);

	if (Evento.type == SDL_KEYDOWN)
	switch (Evento.key.keysym.sym)
	{
		case SDLK_RETURN:
		case SDLK_SPACE:
		lido = 1;
		selected=cursorY+1;
		break;
		case SDLK_UP:
		cursorY--;
		break;
		case SDLK_DOWN:
		cursorY++;
		break;

	}
	if (Evento.type == SDL_KEYUP)
	switch(Evento.key.keysym.sym)
	{
       		case SDLK_LEFT:
		if (EGO.xvel != STEP) EGO.xvel = 0.0;
       		break;
       		case SDLK_RIGHT:
       		if (EGO.xvel != -STEP) EGO.xvel = 0.0;
       		break;
      		case SDLK_UP:
       		if (EGO.yvel != STEP) EGO.yvel = 0.0;
       		break;
      		case SDLK_DOWN:
       		if (EGO.yvel != -STEP) EGO.yvel = 0.0;
       		break;
	}
  } // while lido!-1




}

void Play_Music(const char musicname[])
{
// This functions plays a music file "musicname"
	if (musica!=NULL)
		{ Mix_HaltMusic(); Mix_FreeMusic(musica); musica=NULL; }
	if (musica == NULL )
		if ( (musica = Mix_LoadMUS(musicname)) == NULL) printf( "MIX_LoadMUS: %s\n",Mix_GetError() );
	if (musica!=NULL)
		if( Mix_PlayMusic(musica,-1) == -1) printf( "MIX_PlayMusic: %s\n",Mix_GetError() );


}

void Play_Snd(const char sndname[])
{
// This functions plays a snd file "sndname"
	if (som!=NULL)
		{ Mix_FreeChunk(som); som=NULL; }
	if (som == NULL )
		if ( (som = Mix_LoadWAV(sndname)) == NULL) printf( "MIX_LoadWAV: %s\n",Mix_GetError() );
	if (som!=NULL)
		if( Mix_PlayChannel(-1, som,0) == -1) printf( "MIX_PlayChannel: %s\n",Mix_GetError() );


}

void Give_Party(int x, int lvl, int nn)
{
// This function adds "nn" party members of tipo="x" with Level="lvl",
// if there is an open slot
	int i;

for (; nn != 0; nn--)
	for (i=1;i<=NTRUPY;i++) {
		if (party[i].tipo == 0)
		{
			party[i].tipo = x;
			party[i].x = EGO.x;
			party[i].y = EGO.y;
			party[i].pxScr = EGO.count_x;
			party[i].pyScr = EGO.count_y;
			party[i].hp = Livro[x].hp+(lvl*5);
			party[i].hpmax = Livro[x].hp+(lvl*5);
			party[i].nivel = lvl;
			party[i].xp = 0;
			party[i].sprite = 0;
			party[i].walkable = 1;
			party[i].partykey = 1;
			party[i].lutando = 0;
			party[i].vivo = 1;
			party[i].select = 0;
			break;
		}
        printf("***party is full;\n");
    }
}

void Remove_Party(int x)
{
// This function removes a party member of tipo = "x"
	int i,a,j;

	for (i=1;i<=NTRUPY;i++)
		if (party[i].tipo == x)
		{
			party[i].tipo = 0;
			party[i].x = 0;
			party[i].y = 0;
			party[i].pxScr = 0;
			party[i].pyScr = 0;
			party[i].hp = 0;
			party[i].hpmax = 0;
			party[i].xp = 0;
			party[i].nivel = 0;
			party[i].sprite = 0;
			party[i].partykey = 0;
			party[i].lutando = 0;
			party[i].vivo = 0;
			party[i].walkable = 0;
			party[i].select = 0;
			break;
		}

	for (j=1;j<NTRUPY;j++)
		if (party[j].tipo == 0)
			for (a=1;a<=NTRUPY;a++)
				if (a > j && party[a].tipo != 0)
				{
					party[j].tipo=party[a].tipo;
					party[j].x = party[a].x;
					party[j].y = party[a].y;
					party[j].pxScr = party[a].pxScr;
					party[j].pyScr = party[a].pyScr;
					party[j].hp = party[a].hp;
					party[j].hpmax = party[a].hpmax;
					party[j].xp = party[a].xp;
					party[j].nivel = party[a].nivel;
					party[j].sprite = party[a].sprite;
					party[j].vivo = party[a].vivo;
					party[j].partykey = party[a].partykey;
					party[j].lutando = party[a].lutando;
					party[j].walkable = party[a].walkable;
					party[j].select = party[a].select;
					party[a].tipo=0;
					party[a].x = 0;
					party[a].y = 0;
					party[a].pxScr = 0;
					party[a].pyScr = 0;
					party[a].hp = 0;
					party[a].hpmax = 0;
					party[a].xp = 0;
					party[a].nivel = 0;
					party[a].sprite = 0;
					party[a].vivo = 0;
					party[a].partykey = 0;
					party[a].lutando = 0;
					party[a].walkable = 0;
					party[a].select = 0;
					break;
				}

}

void getsimb_T4c()
{
// This is the core of the recursive parser,
// each char is analyzed in order to acquire symbols
	char msg[500];

	int i=0,j=0,achousimbolo=1;
	static int aspas=0;

	if (!feof(scriptpt)) msg[i]= fgetc(scriptpt);
	msg[i+1]='\0';



	if (aspas > 0)
	{
		while ( msg[i] != '"' )
		{
			i++; msg[i]=fgetc(scriptpt); msg[i+1] = '\0';
			if (i >= 350) {
                                    Digue_Window("*script aborted! parsing string too big");
                                    scriptpanic = 1; break; }
		}
		aspas = 0; simb=txt;
		i--; msg[i+1]='\0';
		fseek(scriptpt, -1, SEEK_CUR);
		strcpy(txt_atual, msg);
		return;
	}

	if ( msg[i] == '"' && aspas == 0) aspas++;
	if ( msg[i] == '"' && simb == txt) aspas = 0;

	if ( msg[i] == ' ' && aspas == 0) i--;
	if ( msg[i] == '\n') { linhascript++; i--; }
	if ( msg[i] == '\t') i--;
	if ( msg[i] == '\r') i--;
	if ( msg[i] == '-') { i++; msg[i]=fgetc(scriptpt); msg[i+1]='\0'; }

	while ( msg[i] >= '0' && msg[i] <= '9' )
	{
		i++; msg[i]=fgetc(scriptpt); msg[i+1]='\0';
		if ( msg[i] == ',' || msg[i] == ')' )
		{ i--; msg[i+1]='\0'; fseek(scriptpt, -1, SEEK_CUR); simb = number; n_atual = atoi(msg); return; }
	}
	while ( !feof(scriptpt) && ( (achousimbolo && msg[i] != '(' && msg[i] != ')' && msg[i]!=';' && msg[i]!=',' && msg[i]!='{' && msg[i]!='}' && msg[i]!='"') || i < 0) )
	{
		i++; msg[i]= fgetc(scriptpt);
		if ( msg[i] == ' ') i--;
		if ( msg[i] == '\n' ) { linhascript++; i--; }
		if ( msg[i] == '\t') i--;
  		if ( msg[i] == '\r') i--;
		msg[i+1]= '\0';
		if (feof(scriptpt)) return;
		if (i >= 350) { Digue("*ERR* script aborted");
                                Digue_Window("script aborted!");
                                    scriptpanic = 1; break; }

		for (j=0; j<=N_SIMBS-1; j++) if ( strcmp(msg, simbwords[j]) == 0 ) { simb = j; return; }


	}

	if ( achousimbolo==1 && strlen(msg) == 1 ) for (j=0; j<=N_SIMBS-1; j++) if ( strcmp(msg, simbwords[j]) == 0 )
									{ simb = j; return; }
	if ( achousimbolo==1)
	{
		i--; msg[i+1] = '\0';
		fseek(scriptpt, -1, SEEK_CUR);
		for (j=0; j<=N_FUNCTIONS-1; j++)
			if (strcmp(msg, functionwords[j]) == 0)
			{ simb = functionsym; achousimbolo = 2; strcpy(func_atual, functionwords[j]); }
		if ( achousimbolo == 1 ) {
                char msgbug[1024];
                printf("ERR on line %d of script: INVALID FUNCTION '%s'\n", linhascript, msg);
                sprintf(msgbug, "ERR on line %d of script: INVALID FUNCTION '%s'\n", linhascript, msg);
                Digue_Window(msgbug);
                scriptpanic = 1; return;

            }

	}

	return;
}

int Accept_T4c(Simbolo s)
{
// This function acquires symbols according to proper syntax
	if (s == simb)
	{ getsimb_T4c(); return 1; }
	return 0;
}

int Expect_T4c(Simbolo s)
{

// This function deals with proper syntax of acquired symbols
	if (Accept_T4c(s))
		return 1;

    char msgbug[1024];
	sprintf(msgbug, "ERR at line %d of script: EXPECTED-> %s\n", linhascript, simbwords[s]);
	printf("%s", msgbug);
	Digue_Window(msgbug);
	scriptpanic = 1;
	return 0;
}

int Compare_T4c(Simbolo s)
{
// This functions compares two symbols
	if ( simb != s) {  return 0; }
	return 1;
}

void Block_T4c(int prevCondition, int matchcronos, const char idTag[], int indexCartola)
{
// This function deals with parsing a whole block of a T4c script
// and the logic/syntax of each implemented function

	char str[300] = "";
	int alvox,alvoy,x,y,k,n;
	char **selectoptions;
	int *alvosx, *alvosy, *xs, *ys, *walkz, walked=0;

	if ( (( flagX == inix && flagY == iniy && usandoitem == n_item )) || matchcronos )
	{
		if (Compare_T4c(ifsym) && resultCondition == 1)
			{
				getsimb_T4c();
				Expect_T4c(abrepar);
				if (Accept_T4c(functionsym))
				{
					Block_T4c(resultCondition, matchcronos, NULL, indexCartola); }
				Expect_T4c(fechapar);
				Expect_T4c(abrechave);
				while(!Accept_T4c(fechachave))
				{	if ( Accept_T4c(functionsym) || Compare_T4c(ifsym) )
						Block_T4c(resultCondition, matchcronos, NULL, indexCartola);
					if (scriptpanic) break; }
				if ( resultCondition == 1 ) resultCondition = 0; else resultCondition = 1;
				Expect_T4c(elsesym); Expect_T4c(abrechave);
				while(!Accept_T4c(fechachave))
				{	if ( Accept_T4c(functionsym) || Compare_T4c(ifsym) )
					Block_T4c(resultCondition, matchcronos, NULL, indexCartola);
					if (scriptpanic) break; }
				if ( resultCondition == 0 ) resultCondition = 1;

				return;
			}

// BELOW EACH FUNCTION ACTUAL IMPLEMENTATION AND EXECUTION
    if (strcmp(func_atual, "SetRainy")==0 && resultCondition == 1)
		{Expect_T4c(abrepar); Expect_T4c(number); x = n_atual; Expect_T4c(fechapar);
            if ( x ) { pUddles = x; pUddlelings = x; /*rainy=1;*/ } else rainy = 0;
		return;}

		if (strcmp(func_atual, "SetSkinner")==0 && resultCondition == 1)
		{Expect_T4c(abrepar); Expect_T4c(number); x = n_atual; Expect_T4c(fechapar);
            EGO.tipo = x;
		return;}

		if (strcmp(func_atual, "Lockey")==0 && resultCondition == 1)
		{Expect_T4c(abrepar); Expect_T4c(fechapar);
            if ( !LOCKEY ) LOCKEY = 1; else LOCKEY = 0;
		return;}

		if (strcmp(func_atual, "TeleEGO")==0 && resultCondition == 1)
		{Expect_T4c(abrepar);
		Expect_T4c(number);  alvox=n_atual; Expect_T4c(virgula);
		Expect_T4c(number);  alvoy=n_atual;
		Expect_T4c(fechapar);
		EGO.count_x = alvox; EGO.count_y = alvoy; EGO.x = alvox; EGO.y = alvoy;

		return;}

    if (strcmp(func_atual, "SetYakka")==0 && resultCondition == 1)
		{Expect_T4c(abrepar); Expect_T4c(number); x = n_atual; Expect_T4c(fechapar);
            if ( x ) { yakka = x; ALOHA=FARAWAY+yakka; yekey = yakka; } else { yakka = 1; yekey = 1; }
		return;}
		if (strcmp(func_atual, "SetTanatos")==0 && resultCondition == 1)
		{Expect_T4c(abrepar);
		  Expect_T4c(aspas); Expect_T4c(txt); Expect_T4c(aspas);
		Expect_T4c(fechapar);

        		for (n=1;n<N_CARTOLA;n++)
				 if ( strcmp(cartola[n].id, txt_atual )==0 )
                    cartola[n].hostile = 2;

            return; }
        if (strcmp(func_atual, "SetCount")==0 && resultCondition == 1)
		{Expect_T4c(abrepar);
		 Expect_T4c(number);  alvox=n_atual; Expect_T4c(virgula);
		 Expect_T4c(aspas); Expect_T4c(txt); Expect_T4c(aspas);
		Expect_T4c(fechapar);
            for (n=1;n<N_CARTOLA;n++)
				if ( strcmp(cartola[n].id, txt_atual )==0 )
                        cartola[n].Trigger = alvox;
				return; }
        if (strcmp(func_atual, "doCount")==0 && resultCondition == 1)
		{Expect_T4c(abrepar);
		 Expect_T4c(number);  alvox=n_atual; Expect_T4c(virgula);
		 Expect_T4c(aspas); Expect_T4c(txt); Expect_T4c(aspas);
		Expect_T4c(fechapar);
           for (n=1;n<N_CARTOLA;n++)
				if ( strcmp(cartola[n].id, txt_atual )==0 )
						cartola[n].Trigger -= alvox;

									return; }

		if (strcmp(func_atual, "SetCronos")==0 && resultCondition == 1)
		{Expect_T4c(abrepar);
		 Expect_T4c(number);  alvox=n_atual; Expect_T4c(virgula);
		 Expect_T4c(aspas); Expect_T4c(txt); Expect_T4c(aspas);
		Expect_T4c(fechapar);

                if ( strcmp(cartola[indexCartola].id, txt_atual )==0 ) {
                    if ( !abs(alvox) ) {
                          cartola[indexCartola].Cronos = 0;
                     } else {
                        cartola[indexCartola].Cronos = CRONOS+abs(1000*alvox);
                        if ( alvox < 0 )
                            cartola[indexCartola].Cronos *= -1;
                    }
                }
                else {

            for (n=1;n<N_CARTOLA;n++)
				 if ( strcmp(cartola[n].id, txt_atual )==0 && !cartola[n].Cronos ) {
                     if ( !abs(alvox) ) {
                          cartola[n].Cronos = 0;
                     } else {
                        cartola[n].Cronos = CRONOS+abs(1000*alvox);
                        if ( alvox < 0 )
                            cartola[n].Cronos *= -1;
                    }
                        break;
                }
        }

        return; }
		if (strcmp(func_atual, "mkStruct")==0 && resultCondition == 1)
		{ Expect_T4c(abrepar);
		Expect_T4c(aspas); Expect_T4c(txt); Expect_T4c(aspas);  Expect_T4c(virgula);
		  Expect_T4c(number); alvox=n_atual; Expect_T4c(virgula);
		  Expect_T4c(number); alvoy=n_atual; Expect_T4c(virgula);
		  Expect_T4c(number); x=n_atual; Expect_T4c(virgula);
		  Expect_T4c(number);
		Expect_T4c(fechapar);
		//
			makeStruct(txt_atual, alvox, alvoy, x, n_atual); return; }
		if (strcmp(func_atual, "Digue")==0 && resultCondition == 1)
		{Expect_T4c(abrepar);
		  Expect_T4c(aspas); Expect_T4c(txt); Expect_T4c(aspas);
		 Expect_T4c(fechapar);
		 //
		 Digue(txt_atual); return; }
		if (strcmp(func_atual, "Digue_Window")==0 && resultCondition == 1 )
		{Expect_T4c(abrepar);
		  Expect_T4c(aspas); Expect_T4c(txt); Expect_T4c(aspas);
		 Expect_T4c(fechapar);
		 Digue_Window(txt_atual); return; }
		if (strcmp(func_atual, "Walk")==0 && resultCondition == 1 )
		{ Expect_T4c(abrepar);
		   Expect_T4c(number); alvox=n_atual; Expect_T4c(virgula);
		   Expect_T4c(number);  alvoy = n_atual;
		  Expect_T4c(fechapar);
		 //
		 Walk(alvox, alvoy,alvox,alvoy); return; }
		if (strcmp(func_atual, "Walk_NPC")==0 && resultCondition == 1 )
		{ Expect_T4c(abrepar); Expect_T4c(number); alvox = n_atual; Expect_T4c(virgula);
		    Expect_T4c(number); alvoy = n_atual; Expect_T4c(virgula);
		    Expect_T4c(number); x = n_atual;
		  Expect_T4c(fechapar);
		  //
		  Walk_NPC(alvox, alvoy, x);  return; }

		  if (strcmp(func_atual, "Cinescope")==0 && resultCondition == 1 )
		{ Expect_T4c(abrepar); Expect_T4c(number); alvox = n_atual; Expect_T4c(virgula);
		    Expect_T4c(number); alvoy = n_atual; Expect_T4c(virgula);
		    Expect_T4c(number); x = n_atual;
		  Expect_T4c(fechapar);
		  //
		  DUDEx = alvox;
		  DUDEy = alvoy;
		  QTO = x; ALOHA = (SCREEN_HEIGHT)/(QTO); return; }

		if (strcmp(func_atual, "Give_Item")==0 && resultCondition == 1 )
		{ Expect_T4c(abrepar);
		    Expect_T4c(number); x = n_atual;
		  Expect_T4c(fechapar);
		  //
		  Give_Item(x, inix, iniy); return; }
		if (strcmp(func_atual, "HasItem")==0 && resultCondition == 1 )
		{ Expect_T4c(abrepar);
		   Expect_T4c(number); x = n_atual;
		  Expect_T4c(fechapar);
		  //
		  HasItem(x); return; }
		if (strcmp(func_atual, "HasParty")==0 && resultCondition == 1 )
		{ Expect_T4c(abrepar);
		   Expect_T4c(number); x = n_atual;
		  Expect_T4c(fechapar);
		  //
		  HasParty(x); return; }
		if (strcmp(func_atual, "HasSelect")==0 && resultCondition == 1 )
		{ Expect_T4c(abrepar);
		   Expect_T4c(number); x = n_atual;
		  Expect_T4c(fechapar);
		  //
		  HasSelect(x); return; }
		  if (strcmp(func_atual, "HasWood")==0 && resultCondition == 1 )
		{ Expect_T4c(abrepar);
		   Expect_T4c(number); x = n_atual;
		  Expect_T4c(fechapar);
		  HasWood(x); return; }
		if (strcmp(func_atual, "HasGold")==0 && resultCondition == 1 )
		{ Expect_T4c(abrepar);
		   Expect_T4c(number); x = n_atual;
		  Expect_T4c(fechapar);
		  HasGold(x); return; }
		if (strcmp(func_atual, "HasMission")==0 && resultCondition == 1 )
		{ Expect_T4c(abrepar);
		   Expect_T4c(number);
		  Expect_T4c(fechapar);

		  if (mission[n_atual] == 1) resultCondition = 1; else resultCondition=0; return; }

		  if (strcmp(func_atual, "HasCount")==0 && resultCondition == 1 )
		{ Expect_T4c(abrepar);
		   	   Expect_T4c(aspas); Expect_T4c(txt); Expect_T4c(aspas);
		  Expect_T4c(fechapar);
		   for (n=1;n<=N_CARTOLA-1;n++)
				if ( strcmp(cartola[n].id, txt_atual )==0 ) {
					if ( cartola[n].Trigger <= 0 ) { resultCondition = 1; }
                                else { resultCondition = 0; }
                }
            return; }



		if (strcmp(func_atual, "Give_Gold")==0 && resultCondition == 1)
		{ Expect_T4c(abrepar); Expect_T4c(number); Expect_T4c(fechapar);
				 Give_Gold(n_atual); return; }
		if (strcmp(func_atual, "Give_Wood")==0 && resultCondition == 1)
		{ Expect_T4c(abrepar); Expect_T4c(number); Expect_T4c(fechapar);
				 Give_Wood(n_atual); return; }

		if (strcmp(func_atual, "Give_Xp")==0 && resultCondition == 1)
		{ Expect_T4c(abrepar); Expect_T4c(number); Expect_T4c(fechapar);
		 Give_Xp(n_atual); return; }
		if (strcmp(func_atual, "Give_Mission")==0 && resultCondition == 1)
		{ Expect_T4c(abrepar); Expect_T4c(number); Expect_T4c(fechapar);
		 mission[n_atual]=1; return; }
		if (strcmp(func_atual, "Destroy_Mission")==0 && resultCondition == 1)
		{ Expect_T4c(abrepar); Expect_T4c(number); Expect_T4c(fechapar);
		 mission[n_atual]=0; return; }
		if (strcmp(func_atual, "Give_Hp")==0 && resultCondition == 1)
		{ Expect_T4c(abrepar); Expect_T4c(number); Expect_T4c(fechapar);
		 Give_Hp(n_atual); return; }
		if (strcmp(func_atual, "Destroy_NPC")==0 && resultCondition == 1)
		{ Expect_T4c(abrepar); Expect_T4c(number); alvox=n_atual; Expect_T4c(virgula);
		Expect_T4c(number); alvoy=n_atual; Expect_T4c(fechapar);
		 Destroy_NPC(alvox, alvoy); return; }
		if (strcmp(func_atual, "Kill_NPC")==0 && resultCondition == 1)
		{ Expect_T4c(abrepar); Expect_T4c(number); alvox=n_atual; Expect_T4c(virgula);
		Expect_T4c(number); alvoy=n_atual; Expect_T4c(fechapar);
		 Kill_NPC(alvox, alvoy); return; }
        if (strcmp(func_atual, "spawnModel")==0 && resultCondition == 1)
		{ Expect_T4c(abrepar);
		  Expect_T4c(aspas); Expect_T4c(txt); Expect_T4c(aspas); Expect_T4c(virgula);
		  Expect_T4c(number); x = n_atual; Expect_T4c(virgula);
		 Expect_T4c(number); y= n_atual; Expect_T4c(fechapar); spawnModel(txt_atual, x, y); return; }
		if (strcmp(func_atual, "Create_NPC")==0 && resultCondition == 1)

		{ char buf[300];
            Expect_T4c(abrepar);
		  Expect_T4c(aspas); Expect_T4c(txt); strcpy(buf, txt_atual); Expect_T4c(aspas); Expect_T4c(virgula);
		  Expect_T4c(number); x = n_atual; Expect_T4c(virgula);
		 Expect_T4c(number); y= n_atual; Expect_T4c(virgula);  Expect_T4c(number); n= n_atual;
		Expect_T4c(virgula); Expect_T4c(number); alvox=n_atual; Expect_T4c(virgula);
		Expect_T4c(number); alvoy=n_atual; Expect_T4c(virgula); Expect_T4c(number); k=n_atual;
		Expect_T4c(virgula); Expect_T4c(aspas); Expect_T4c(txt); Expect_T4c(aspas); Expect_T4c(fechapar);
		Create_NPC(buf, x, y, n, alvox, alvoy, k, txt_atual); return; }
		if (strcmp(func_atual, "Create_Item")==0 && resultCondition == 1)
		{ Expect_T4c(abrepar); Expect_T4c(number); x = n_atual; Expect_T4c(virgula);
		 Expect_T4c(number); alvox= n_atual; Expect_T4c(virgula);  Expect_T4c(number); 			alvoy=n_atual; Expect_T4c(fechapar);
		 Create_Item(x, alvox, alvoy); return; }
		 if (strcmp(func_atual, "SetSpiel") ==0 && resultCondition == 1 )
        { Expect_T4c(abrepar); Expect_T4c(number); spiel = n_atual; Expect_T4c(fechapar); return; }
		 if (strcmp(func_atual, "SetLux")==0 && resultCondition == 1)
		{ Expect_T4c(abrepar); Expect_T4c(number); x = n_atual; Expect_T4c(virgula); Expect_T4c(number); y = n_atual; Expect_T4c(fechapar);
		Lux += x; SOLARIS = y; return; }
		if (strcmp(func_atual, "Destroy_Item")==0 && resultCondition == 1)
		{ Expect_T4c(abrepar); Expect_T4c(number); x = n_atual; Expect_T4c(virgula);
		Expect_T4c(number); y=n_atual; Expect_T4c(fechapar);
		Destroy_Item(x, y); return; }
		if (strcmp(func_atual, "Destroy_Script")==0 && resultCondition == 1)
		{ Destroy_Flag(n_mapa,inix,iniy,n_mapa); Expect_T4c(abrepar); Expect_T4c(fechapar);  return; }
		if (strcmp(func_atual, "Destroy_Flag")==0 && resultCondition == 1)
		{ Expect_T4c(abrepar); Expect_T4c(number); x=n_atual; Expect_T4c(virgula);
		Expect_T4c(number); alvox=n_atual; Expect_T4c(virgula);
		Expect_T4c(number); alvoy=n_atual; Expect_T4c(fechapar); Destroy_Flag(x, alvox, alvoy, n_mapa); return; }
		if (strcmp(func_atual, "Create_Flag")==0 && resultCondition == 1)
		{ Expect_T4c(abrepar); Expect_T4c(number); x=n_atual; Expect_T4c(virgula);
		Expect_T4c(number); y=n_atual; Expect_T4c(virgula);
		Expect_T4c(number); alvox=n_atual; Expect_T4c(virgula);
		Expect_T4c(number); alvoy=n_atual; if (Accept_T4c(virgula)) {
						Expect_T4c(aspas); Expect_T4c(txt);
						strcpy(str, txt_atual); Expect_T4c(aspas);
						}
					Expect_T4c(fechapar);
		Create_Flag(x,y,alvox,alvoy,n_mapa, str); return; }
		if (strcmp(func_atual, "Change_Flag")==0 && resultCondition == 1 )
		{ Expect_T4c(abrepar); Expect_T4c(number); x=n_atual; Expect_T4c(virgula);
		Expect_T4c(number); y=n_atual; Expect_T4c(virgula);
		Expect_T4c(number); alvox=n_atual; Expect_T4c(virgula);
		Expect_T4c(number); alvoy=n_atual; Expect_T4c(fechapar);
		Change_Flag(x,y, alvox, alvoy, n_mapa); return; }
		if (strcmp(func_atual, "Select")==0 && resultCondition == 1 )
		{Expect_T4c(abrepar); Expect_T4c(number); x=n_atual;
		selectoptions = malloc(x*sizeof(char *));
		if (selectoptions == NULL) { printf("Select: err alloc\n"); return; }
		for (k=0; k<=x-1; k++)
			{ selectoptions[k] = malloc(351*sizeof(char)); if (selectoptions[k] == NULL ) { printf("Select: erro alocando memória\n"); return; } }
		for (k=0; k<=x-1; k++)
			{ Expect_T4c(virgula); Expect_T4c(aspas); Expect_T4c(txt);
			  strcpy(selectoptions[k], txt_atual); Expect_T4c(aspas); }
		Expect_T4c(fechapar); Select_Opt(x, selectoptions);
		for (k=0; k<=x-1;k++)
			free(selectoptions[k]);
        free(selectoptions); return; }
		if (strcmp(func_atual, "Play_Music")==0 && resultCondition == 1 )
		{ Expect_T4c(abrepar); Expect_T4c(aspas); Expect_T4c(txt); Expect_T4c(aspas); Expect_T4c(fechapar);
		 Play_Music(txt_atual); return; }
		if (strcmp(func_atual, "Play_Snd")==0 && resultCondition == 1 )
		{ Expect_T4c(abrepar); Expect_T4c(aspas); Expect_T4c(txt); Expect_T4c(aspas); Expect_T4c(fechapar);
		 Play_Snd(txt_atual); return; }
		if (strcmp(func_atual, "Give_Party")==0 && resultCondition == 1 )
		{ Expect_T4c(abrepar); Expect_T4c(number); x = n_atual; Expect_T4c(virgula);
		  Expect_T4c(number); y=n_atual; Expect_T4c(virgula);
		  Expect_T4c(number); n=n_atual; Expect_T4c(fechapar);
		 Give_Party(x, y, n); return; }
		if (strcmp(func_atual, "Remove_Party")==0 && resultCondition == 1 )
		{ Expect_T4c(abrepar); Expect_T4c(number); x = n_atual; Expect_T4c(fechapar);
		 Remove_Party(x); return; }
		if (strcmp(func_atual, "Change_Obj")==0 && resultCondition == 1 )
                { Expect_T4c(abrepar); Expect_T4c(number); alvox = n_atual; Expect_T4c(virgula); Expect_T4c(number); alvoy = n_atual;
                        Expect_T4c(virgula); Expect_T4c(number); x= n_atual; Expect_T4c(fechapar);
                 mapa[alvoy][alvox].obj = x; return; }
        if (strcmp(func_atual, "Splash")==0 && resultCondition == 1 )
                { Expect_T4c(abrepar); Expect_T4c(number); alvox = n_atual; Expect_T4c(virgula);
                Expect_T4c(number); alvoy = n_atual; Expect_T4c(virgula);
                Expect_T4c(number); x= n_atual; Expect_T4c(fechapar);
                if ( alvox < 0 ) { alvox = EGO.x+(rand()%(abs(alvox)-abs(alvoy)))*-1*(rand()%2); alvoy = EGO.y+(rand()%(abs(alvoy)))*-1*(rand()%2); }
                 ether[alvoy][alvox].tipo = x; ether[alvoy][alvox].pxScr = alvox; ether[alvoy][alvox].pyScr = alvoy; return; }
        if (strcmp(func_atual, "Change_Base")==0 && resultCondition == 1 )
                { Expect_T4c(abrepar); Expect_T4c(number); alvox = n_atual; Expect_T4c(virgula); Expect_T4c(number); alvoy = n_atual;
                        Expect_T4c(virgula); Expect_T4c(number); x= n_atual; Expect_T4c(fechapar);
                 mapa[alvoy][alvox].base = x; return; }
            if (strcmp(func_atual, "Change_Top")==0 && resultCondition == 1 )
                { Expect_T4c(abrepar); Expect_T4c(number); alvox = n_atual; Expect_T4c(virgula); Expect_T4c(number); alvoy = n_atual;
                        Expect_T4c(virgula); Expect_T4c(number); x= n_atual; Expect_T4c(fechapar);
                 mapa[alvoy][alvox].top = x; return; }
//////////////////////////////////////////////////
		if (strcmp(func_atual, "Walk_NPCS")==0 && resultCondition == 1 )
		{ Expect_T4c(abrepar); Expect_T4c(number); n = n_atual;
		  alvosx = malloc(n*sizeof(int)); alvosy = malloc(n*sizeof(int));
		  xs = malloc(n*sizeof(int)); ys = malloc(n*sizeof(int));
		  walkz = malloc(n*sizeof(int));
		  for (k=0; k<= n-1; k++)
		  {
		   Expect_T4c(virgula);
		   Expect_T4c(number); alvosx[k] = n_atual; Expect_T4c(virgula);
		   Expect_T4c(number); alvosy[k] = n_atual; Expect_T4c(virgula); Expect_T4c(number); xs[k] = n_atual;
		   Expect_T4c(virgula); Expect_T4c(number); ys[k] = n_atual;
   		  }
		  Expect_T4c(fechapar);
		while ( walked == 0 )
		{
		  Act_Tempo();
		  if (tac.mov == 1)
		  {
		    walked = 1;
    		    for (k=0; k<=n-1; k++)
		    	{ walkz[k] = Walk_NPCS(alvosx[k], alvosy[k], xs[k], ys[k]);
			  if ( walkz[k] == 1 ) walked = 0; }
		     Desenha_Tudo();
			Desenha_stats();

			SDL_RenderPresent(window_renderer);

		   tac.mov = 0;
		   }
		}
		free(alvosx); free(alvosy); free(xs); free(ys); free(walkz);
		  return; }

	} // if flagX == inix && flagY == iniy

	if (Compare_T4c(ifsym))
			{

				getsimb_T4c();
				Expect_T4c(abrepar);
				if (Accept_T4c(functionsym))
					Block_T4c(resultCondition, matchcronos, NULL, indexCartola);
				Expect_T4c(fechapar);
				Expect_T4c(abrechave);
				while(!Accept_T4c(fechachave))
				{	if ( Accept_T4c(functionsym) || Compare_T4c(ifsym) )
						Block_T4c(resultCondition, matchcronos, NULL, indexCartola);
					if (scriptpanic) break; }
				Expect_T4c(elsesym); Expect_T4c(abrechave);
				while(!Accept_T4c(fechachave))
				{	if ( Accept_T4c(functionsym) || Compare_T4c(ifsym) )
						Block_T4c(resultCondition, matchcronos, NULL, indexCartola);
					if (scriptpanic) break; }
				return;
			}

//////////////// BELOW repeat FUNCTIONS SYNTAX FOR PARSING NO-OP "If" blocks
// when "If" resultcondition is not true
	if (strcmp(func_atual, "Digue")==0 )
	{ Expect_T4c(abrepar); Expect_T4c(aspas); Expect_T4c(txt); Expect_T4c(aspas); Expect_T4c(fechapar);  return;
	}
	if (strcmp(func_atual, "Digue_Window")==0)
	{ Expect_T4c(abrepar); Expect_T4c(aspas); Expect_T4c(txt); Expect_T4c(aspas); Expect_T4c(fechapar);  return;
	}
	if (strcmp(func_atual, "Walk")==0)
	{ Expect_T4c(abrepar); Expect_T4c(number); Expect_T4c(virgula);
	Expect_T4c(number);  Expect_T4c(fechapar);  return;
	}
	if (strcmp(func_atual, "Walk_NPC")==0)
	{ Expect_T4c(abrepar); Expect_T4c(number); Expect_T4c(virgula);
	  Expect_T4c(number); Expect_T4c(virgula); Expect_T4c(number);
	  Expect_T4c(fechapar);  return;
	}
	if (strcmp(func_atual, "Cinescope")==0)
	{ Expect_T4c(abrepar); Expect_T4c(number); Expect_T4c(virgula);
	  Expect_T4c(number); Expect_T4c(virgula);
	  Expect_T4c(number); Expect_T4c(fechapar);  return;
	}
	if (strcmp(func_atual, "TeleEGO")==0 )
		{Expect_T4c(abrepar);
		Expect_T4c(number);  Expect_T4c(virgula);
		Expect_T4c(number); Expect_T4c(fechapar);
                                            return;}

	if (strcmp(func_atual, "Walk_NPCS")==0)
	{ Expect_T4c(abrepar); Expect_T4c(number); x=n_atual;
	  for (k=0;k<=x-1;k++)
	 {
	    Expect_T4c(virgula); Expect_T4c(number); Expect_T4c(virgula);
	    Expect_T4c(number); Expect_T4c(virgula); Expect_T4c(number); Expect_T4c(virgula);
	    Expect_T4c(number);
	 }
	  Expect_T4c(fechapar);  return;
	}
	if (strcmp(func_atual, "Give_Item")==0 )
	{  Expect_T4c(abrepar); Expect_T4c(number); Expect_T4c(fechapar);  return; }
	if (strcmp(func_atual, "Lockey")==0 )
	{  Expect_T4c(abrepar);  Expect_T4c(fechapar);  return; }
	if (strcmp(func_atual, "HasItem")==0 )
	{  Expect_T4c(abrepar); Expect_T4c(number); Expect_T4c(fechapar);  return; }
	if (strcmp(func_atual, "HasParty")==0 )
	{  Expect_T4c(abrepar); Expect_T4c(number); Expect_T4c(fechapar);  return; }
	if (strcmp(func_atual, "HasSelect")==0 )
	{ Expect_T4c(abrepar); Expect_T4c(number); Expect_T4c(fechapar); return; }
	if (strcmp(func_atual, "HasWood")==0 )
	{ Expect_T4c(abrepar); Expect_T4c(number); Expect_T4c(fechapar); return; }
	if (strcmp(func_atual, "HasGold")==0 )
	{ Expect_T4c(abrepar); Expect_T4c(number); Expect_T4c(fechapar); return; }
	if (strcmp(func_atual, "HasMission")==0 )
	{ Expect_T4c(abrepar); Expect_T4c(number); Expect_T4c(fechapar); return; }
	if (strcmp(func_atual, "Give_Gold")==0 )
	{  Expect_T4c(abrepar); Expect_T4c(number); Expect_T4c(fechapar); return; }
	if (strcmp(func_atual, "Give_Wood")==0 )
	{  Expect_T4c(abrepar); Expect_T4c(number); Expect_T4c(fechapar); return; }
	if (strcmp(func_atual, "Give_Xp")==0 )
	{  Expect_T4c(abrepar); Expect_T4c(number); Expect_T4c(fechapar); return; }
	if (strcmp(func_atual, "Give_Hp")==0 )
	{  Expect_T4c(abrepar); Expect_T4c(number); Expect_T4c(fechapar); return; }
	if (strcmp(func_atual, "Give_Mission")==0 )
	{  Expect_T4c(abrepar); Expect_T4c(number); Expect_T4c(fechapar); return; }
	if (strcmp(func_atual, "Destroy_Mission")==0 )
	{ Expect_T4c(abrepar); Expect_T4c(number); Expect_T4c(fechapar); return; }
	if (strcmp(func_atual, "Destroy_NPC")==0 )
	{ Expect_T4c(abrepar); Expect_T4c(number); Expect_T4c(virgula); Expect_T4c(number); Expect_T4c(fechapar); return; }
	if (strcmp(func_atual, "Kill_NPC")==0 )
	{ Expect_T4c(abrepar); Expect_T4c(number); Expect_T4c(virgula); Expect_T4c(number); Expect_T4c(fechapar); return; }
	if (strcmp(func_atual, "spawnModel")==0 )
	{ Expect_T4c(abrepar);
	Expect_T4c(aspas); Expect_T4c(txt); Expect_T4c(aspas); Expect_T4c(virgula);
	Expect_T4c(number); Expect_T4c(virgula); Expect_T4c(number); Expect_T4c(fechapar); return; }
	if (strcmp(func_atual, "Create_NPC")==0 )
	{ Expect_T4c(abrepar);
	Expect_T4c(aspas); Expect_T4c(txt); Expect_T4c(aspas); Expect_T4c(virgula);
	Expect_T4c(number); Expect_T4c(virgula); Expect_T4c(number); Expect_T4c(virgula);
	 Expect_T4c(number); Expect_T4c(virgula); Expect_T4c(number); Expect_T4c(virgula);
	 Expect_T4c(number); Expect_T4c(virgula); Expect_T4c(number);
	 Expect_T4c(virgula); Expect_T4c(aspas); Expect_T4c(txt); Expect_T4c(aspas); Expect_T4c(fechapar); return; }
	if (strcmp(func_atual, "Create_Item")==0)
	{ Expect_T4c(abrepar); Expect_T4c(number); Expect_T4c(virgula); Expect_T4c(number); Expect_T4c(virgula);
	  Expect_T4c(number); Expect_T4c(fechapar); return; }
	if (strcmp(func_atual, "Destroy_Item")==0)
	{ Expect_T4c(abrepar); Expect_T4c(number); Expect_T4c(virgula);
	Expect_T4c(number); Expect_T4c(fechapar); return; }
	if (strcmp(func_atual, "SetSpiel") ==0)
	{ Expect_T4c(abrepar); Expect_T4c(number); Expect_T4c(fechapar); return; }
	if (strcmp(func_atual, "SetLux") ==0)
	{ Expect_T4c(abrepar); Expect_T4c(number); Expect_T4c(virgula); Expect_T4c(number); Expect_T4c(fechapar); return; }
	if (strcmp(func_atual, "Destroy_Script")==0)
	{ Expect_T4c(abrepar); Expect_T4c(fechapar); return; }
	if (strcmp(func_atual, "Destroy_Flag")==0 )
	{ Expect_T4c(abrepar); Expect_T4c(number); Expect_T4c(virgula); Expect_T4c(number); Expect_T4c(virgula);
	 Expect_T4c(number); Expect_T4c(fechapar); return; }
	if (strcmp(func_atual, "Create_Flag")==0 )
	{ Expect_T4c(abrepar); Expect_T4c(number); Expect_T4c(virgula); Expect_T4c(number); Expect_T4c(virgula);
	Expect_T4c(number); Expect_T4c(virgula); Expect_T4c(number); if (Accept_T4c(virgula)) {
						Expect_T4c(aspas); Expect_T4c(txt); Expect_T4c(aspas); }
		Expect_T4c(fechapar);return; }
	if (strcmp(func_atual, "Change_Flag")==0 )
	{ Expect_T4c(abrepar); Expect_T4c(number); Expect_T4c(virgula); Expect_T4c(number); Expect_T4c(virgula);
	Expect_T4c(number); Expect_T4c(virgula); Expect_T4c(number); Expect_T4c(fechapar);return; }
	 if (strcmp(func_atual, "Change_Obj")==0 )
        { Expect_T4c(abrepar); Expect_T4c(number); Expect_T4c(virgula); Expect_T4c(number);
          Expect_T4c(virgula); Expect_T4c(number); Expect_T4c(fechapar); return; }
           if (strcmp(func_atual, "Splash")==0 )
        { Expect_T4c(abrepar); Expect_T4c(number); Expect_T4c(virgula); Expect_T4c(number);
          Expect_T4c(virgula); Expect_T4c(number); Expect_T4c(fechapar); return; }
    if (strcmp(func_atual, "Change_Base")==0 )
        { Expect_T4c(abrepar); Expect_T4c(number); Expect_T4c(virgula); Expect_T4c(number);
          Expect_T4c(virgula); Expect_T4c(number); Expect_T4c(fechapar); return; }
     if (strcmp(func_atual, "Change_Top")==0 )
        { Expect_T4c(abrepar); Expect_T4c(number); Expect_T4c(virgula); Expect_T4c(number);
          Expect_T4c(virgula); Expect_T4c(number); Expect_T4c(fechapar); return; }
	if (strcmp(func_atual, "Select")==0 )
	{ Expect_T4c(abrepar); Expect_T4c(number); x=n_atual;
	  for (k=0; k<=x-1; k++)
	{ Expect_T4c(virgula); Expect_T4c(aspas); Expect_T4c(txt); Expect_T4c(aspas); }
	  Expect_T4c(fechapar); return; }
	if (strcmp(func_atual, "Play_Music")==0 )
	{ Expect_T4c(abrepar); Expect_T4c(aspas); Expect_T4c(txt); Expect_T4c(aspas); Expect_T4c(fechapar); return; }
	if (strcmp(func_atual, "Play_Snd")==0 )
	{ Expect_T4c(abrepar); Expect_T4c(aspas); Expect_T4c(txt); Expect_T4c(aspas); Expect_T4c(fechapar); return; }
	if (strcmp(func_atual, "Give_Party")==0 )
	{ Expect_T4c(abrepar); Expect_T4c(number); Expect_T4c(virgula);
	Expect_T4c(number); Expect_T4c(virgula);
	Expect_T4c(number); Expect_T4c(fechapar); return; }
	if (strcmp(func_atual, "Remove_Party")==0 )
	{ Expect_T4c(abrepar); Expect_T4c(number); Expect_T4c(fechapar); return; }
	if (strcmp(func_atual, "mkStruct")==0 )
	{ Expect_T4c(abrepar); Expect_T4c(aspas); Expect_T4c(txt); Expect_T4c(aspas); Expect_T4c(virgula);
	Expect_T4c(number); Expect_T4c(virgula); Expect_T4c(number); Expect_T4c(virgula);
	  Expect_T4c(number); Expect_T4c(virgula); Expect_T4c(number);
	  Expect_T4c(fechapar); return; }
	if (strcmp(func_atual, "SetCronos")==0 )
		{Expect_T4c(abrepar);
		 Expect_T4c(number); Expect_T4c(virgula); Expect_T4c(aspas); Expect_T4c(txt); Expect_T4c(aspas);
		Expect_T4c(fechapar); return; }
	if (strcmp(func_atual, "SetCount")==0 )
		{Expect_T4c(abrepar);
		 Expect_T4c(number); Expect_T4c(virgula); Expect_T4c(aspas); Expect_T4c(txt); Expect_T4c(aspas);
		Expect_T4c(fechapar); return; }
		 if (strcmp(func_atual, "SetRainy")==0 )
		{Expect_T4c(abrepar); Expect_T4c(number);	Expect_T4c(fechapar); return; }
		if (strcmp(func_atual, "SetSkinner")==0 )
		{Expect_T4c(abrepar); Expect_T4c(number);	Expect_T4c(fechapar); return; }
		 if (strcmp(func_atual, "SetYakka")==0 )
		{Expect_T4c(abrepar); Expect_T4c(number);	Expect_T4c(fechapar); return; }
		if (strcmp(func_atual, "doCount")==0 )
		{Expect_T4c(abrepar);
		 Expect_T4c(number); Expect_T4c(virgula); Expect_T4c(aspas); Expect_T4c(txt); Expect_T4c(aspas);
		Expect_T4c(fechapar); return; }
		if (strcmp(func_atual, "HasCount")==0 )
		{Expect_T4c(abrepar);
		 Expect_T4c(aspas); Expect_T4c(txt); Expect_T4c(aspas);
		Expect_T4c(fechapar); return; }
	if (strcmp(func_atual, "SetTanatos")==0 )
		{Expect_T4c(abrepar);
		 Expect_T4c(aspas); Expect_T4c(txt); Expect_T4c(aspas);
		Expect_T4c(fechapar); return; }
////////////////////////////////////////////////////////////////////

		// HERE WE DEAL WITH Ignite("iDT") blocks
		 while(Accept_T4c(ignisym)) {
			Expect_T4c(abrepar);
			 Expect_T4c(aspas);
				Expect_T4c(txt);
			matchcronos = 0; resultCondition = 0;
			if ( idTag != NULL )
			     if ( strcmp( idTag, txt_atual )==0 )
			     	{  matchcronos = 1;
					resultCondition = 1; }
			Expect_T4c(aspas);
		       Expect_T4c(fechapar);
		Expect_T4c(abrechave);
		while (!Accept_T4c(fechachave))
		{
			if (Accept_T4c(functionsym) || Compare_T4c(ifsym))
				Block_T4c(resultCondition, matchcronos, NULL, indexCartola);
			if (scriptpanic) break;
		}
			resultCondition = prevCondition;
	      }

// HERE WE DEAL WITH Flag(x,y) blocks
    while (Accept_T4c(flagsym))
    {
            Expect_T4c(abrepar);
				Expect_T4c(number);  flagX = n_atual;
			  Expect_T4c(virgula); Expect_T4c(number); flagY = n_atual;
		  Expect_T4c(fechapar);
			if ( idTag != NULL )
				resultCondition = 0;
		Expect_T4c(abrechave);
		while (!Accept_T4c(fechachave))
			{
				if (Accept_T4c(functionsym) || Compare_T4c(ifsym))
					Block_T4c(resultCondition, matchcronos, NULL, indexCartola);
				if (scriptpanic) break;
			}
			resultCondition = prevCondition;
		}

}



int Act_T4c(const char idTag[], int indexCartola)
{
// This is the recursive parser main function

	char msg[20];


	if ( !rodascript )
		{ inix = EGO.x; iniy = EGO.y; }
	else {	inix = cartolax; iniy = cartolay; }

	printf("%d=flag, %d=rodascript %d,%d\n", mapa[iniy][inix].flag, rodascript, inix, iniy);

	sprintf(msg, "res/%d.t4c", n_mapa);
	printf("<script-> %s. . .at (%d,%d)\n", msg,EGO.x,EGO.y);
	if ( (scriptpt = fopen(msg, "r")) == NULL) { printf ("Err reading %s\n",msg); return 1; }
	linhascript = 1; scriptpanic = 0;
		strcpy(func_atual, "nada");
		getsimb_T4c();
		Block_T4c(resultCondition, matchCronos, idTag, indexCartola);
    printf(">done script-> %s. . .at (%d,%d)\n", msg,EGO.x,EGO.y);
	fclose(scriptpt);

	if ( mapa[iniy][inix].flag == 54 )
	 	 //Destroy_Flag(n_mapa,inix,iniy,n_mapa);
	 	 Change_Flag(0,n_mapa,inix,iniy,n_mapa);


	return 0;

}




void makeStruct (const char iDT[], int alvox, int alvoy, char tipo, int x) {
// This function will be discontinued (?)
// spawn model replaces it using models.dat
/*
   switch ( tipo ) {
        case 0:
	default:
        break;
       case 1: // arvre
                                        mapa[alvoy][alvox].top = 133;
                                        mapa[alvoy][alvox+1].top = 134;
                                        mapa[alvoy][alvox-1].top = 132;
                                        mapa[alvoy][alvox].top = 130;
                                        mapa[alvoy][alvox+1].top = 131;
                                        mapa[alvoy][alvox-1].top = 129;
                                        mapa[alvoy+1][alvox].obj = 106;
        break;
       case 2: // arvrim
                                        mapa[alvoy][alvox].top = 139;
                                        mapa[alvoy][alvox+1].top = 140;
                                        mapa[alvoy][alvox-1].top = 138;
                                        mapa[alvoy-1][alvox].top = 136;
                                        mapa[alvoy-1][alvox+1].top = 137;
                                        mapa[alvoy-1][alvox-1].top = 135;
                                        mapa[alvoy+1][alvox].obj = 143;
         break;
        case 3: // Casita top
                                    mapa[alvoy-1][alvox-1].obj = 62;
                                    mapa[alvoy-1][alvox].obj = 63;
                                    mapa[alvoy-1][alvox+1].obj = 64;
                                    mapa[alvoy][alvox-1].obj = 65;
                                    mapa[alvoy][alvox].obj = 66;
                                    mapa[alvoy][alvox+1].obj = 67;
                                     mapa[alvoy-2][alvox-1].top = 144;
                                     mapa[alvoy-2][alvox].top = 145;
                                     mapa[alvoy-2][alvox+1].top = 146;

        break;
        case 4: // Casita bottom
                                    mapa[alvoy][alvox-1].obj = 71;
                                    mapa[alvoy][alvox].obj = 0;
                                    mapa[alvoy][alvox+1].obj = 72;
        break;
	 case 11: // wood blocks

                                    mapa[alvoy][alvox].obj = 118;
                                    mapa[alvoy+1][alvox].obj = 117;
                                    mapa[alvoy+2][alvox+2].obj = 118;
                                    mapa[alvoy+3][alvox+2].obj = 117;
	 	break;
	  case 12: // barril
                                    mapa[alvoy][alvox].obj = 81;
	  break;

	   case 13: // espantalho
                                    mapa[alvoy][alvox].obj = 108;
	   break;

	   case 10: // door
                                    mapa[alvoy][alvox].obj = 180;
	   break;

        }
*/

    int k=0;

    for (int i=0;i<x;i++)
     for (int ii=0;ii<x;ii++ ) {
        mapa[alvoy+i][alvox+ii].base = 0;
        mapa[alvoy+i][alvox+ii].obj = tipo+k;
        k++;
    }

}
